<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>circuit_knitting_toolbox.entanglement_forging.entanglement_forging_knitter &#8212; Circuit Knitting Toolbox 0.1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/jupyter-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/thebelab.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/gallery.css" />
    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/sphinx_highlight.js"></script>
    <script src="../../../_static/thebelab-helper.js"></script>
    <script src="../../../_static/clipboard.min.js"></script>
    <script src="../../../_static/copybutton.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for circuit_knitting_toolbox.entanglement_forging.entanglement_forging_knitter</h1><div class="highlight"><pre>
<span></span><span class="c1"># This code is a Qiskit project.</span>

<span class="c1"># (C) Copyright IBM 2022.</span>

<span class="c1"># This code is licensed under the Apache License, Version 2.0. You may</span>
<span class="c1"># obtain a copy of this license in the LICENSE.txt file in the root directory</span>
<span class="c1"># of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.</span>
<span class="c1"># Any modifications or derivative works of this code must retain this</span>
<span class="c1"># copyright notice, and modified files need to carry a notice indicating</span>
<span class="c1"># that they have been altered from the originals.</span>

<span class="sd">&quot;&quot;&quot;File containing the knitter class and associated functions.&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Any</span>
<span class="kn">from</span> <span class="nn">concurrent.futures</span> <span class="kn">import</span> <span class="n">ThreadPoolExecutor</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">qiskit</span> <span class="kn">import</span> <span class="n">QuantumCircuit</span>
<span class="kn">from</span> <span class="nn">qiskit.quantum_info</span> <span class="kn">import</span> <span class="n">Pauli</span>
<span class="kn">from</span> <span class="nn">qiskit.primitives</span> <span class="kn">import</span> <span class="n">Estimator</span> <span class="k">as</span> <span class="n">TestEstimator</span>
<span class="kn">from</span> <span class="nn">qiskit_ibm_runtime</span> <span class="kn">import</span> <span class="n">QiskitRuntimeService</span><span class="p">,</span> <span class="n">Session</span><span class="p">,</span> <span class="n">Options</span><span class="p">,</span> <span class="n">Estimator</span>

<span class="kn">from</span> <span class="nn">.entanglement_forging_ansatz</span> <span class="kn">import</span> <span class="n">EntanglementForgingAnsatz</span>
<span class="kn">from</span> <span class="nn">.entanglement_forging_operator</span> <span class="kn">import</span> <span class="n">EntanglementForgingOperator</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<div class="viewcode-block" id="EntanglementForgingKnitter"><a class="viewcode-back" href="../../../stubs/circuit_knitting_toolbox.entanglement_forging.EntanglementForgingKnitter.html#circuit_knitting_toolbox.entanglement_forging.EntanglementForgingKnitter">[docs]</a><span class="k">class</span> <span class="nc">EntanglementForgingKnitter</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Container for Knitter class functions and attributes.</span>

<span class="sd">    A class which performs entanglement forging and returns the</span>
<span class="sd">    ground state energy and Schmidt coefficients found for given</span>
<span class="sd">    ansatz parameters and Schmidt coefficients.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="EntanglementForgingKnitter.__init__"><a class="viewcode-back" href="../../../stubs/circuit_knitting_toolbox.entanglement_forging.EntanglementForgingKnitter.html#circuit_knitting_toolbox.entanglement_forging.EntanglementForgingKnitter.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ansatz</span><span class="p">:</span> <span class="n">EntanglementForgingAnsatz</span><span class="p">,</span>
        <span class="n">service</span><span class="p">:</span> <span class="n">QiskitRuntimeService</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">backend_names</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">options</span><span class="p">:</span> <span class="n">Options</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">Options</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assign the necessary member variables.</span>

<span class="sd">        Args:</span>
<span class="sd">            - ansatz (EntanglementForgingAnsatz): The container for the circuit structure and bitstrings</span>
<span class="sd">                to be used (and generate the stateprep circuits)</span>
<span class="sd">            - service (QiskitRuntimeService): The service used to spawn Qiskit primitives and runtime jobs</span>
<span class="sd">            - backend_names (list[str]): Names of the backends to use for calculating expectation values</span>
<span class="sd">            - options (list[Options]): Options to use with the backends</span>

<span class="sd">        Returns:</span>
<span class="sd">            - None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Call backend_names setter to update the session_ids hidden class field</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_session_ids</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_backend_names</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_options</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Options</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Call constructors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">backend_names</span> <span class="o">=</span> <span class="n">backend_names</span>  <span class="c1"># type: ignore</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">options</span> <span class="o">=</span> <span class="n">options</span>

        <span class="c1"># The service hidden class field is a json representing the QiskitRuntimeService object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_service</span> <span class="o">=</span> <span class="n">service</span><span class="o">.</span><span class="n">active_account</span><span class="p">()</span> <span class="k">if</span> <span class="n">service</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">service</span>

        <span class="c1"># Save the parameterized ansatz and bitstrings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ansatz</span><span class="p">:</span> <span class="n">EntanglementForgingAnsatz</span> <span class="o">=</span> <span class="n">EntanglementForgingAnsatz</span><span class="p">(</span>
            <span class="n">circuit_u</span><span class="o">=</span><span class="n">ansatz</span><span class="o">.</span><span class="n">circuit_u</span><span class="p">,</span>
            <span class="n">bitstrings_u</span><span class="o">=</span><span class="n">ansatz</span><span class="o">.</span><span class="n">bitstrings_u</span><span class="p">,</span>
            <span class="n">bitstrings_v</span><span class="o">=</span><span class="n">ansatz</span><span class="o">.</span><span class="n">bitstrings_v</span> <span class="ow">or</span> <span class="n">ansatz</span><span class="o">.</span><span class="n">bitstrings_u</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># self._tensor_circuits   = [|b1âŸ©,|b2âŸ©,...,|b2^NâŸ©]</span>
        <span class="c1"># self._superpos_circuits = [</span>
        <span class="c1">#           |ğœ™^0_ğ‘2ğ‘1âŸ©,|ğœ™^2_ğ‘2ğ‘1âŸ©,</span>
        <span class="c1">#           |ğœ™^0_ğ‘3ğ‘1âŸ©,|ğœ™^2_ğ‘3ğ‘1âŸ©,|ğœ™^0_ğ‘3ğ‘2âŸ©,|ğœ™^2_ğ‘3ğ‘2âŸ©</span>
        <span class="c1">#           |ğœ™^0_ğ‘4ğ‘1âŸ©,|ğœ™^2_ğ‘4ğ‘1âŸ©,|ğœ™^0_ğ‘4ğ‘2âŸ©,|ğœ™^2_ğ‘4ğ‘2âŸ©,|ğœ™^0_ğ‘4ğ‘3âŸ©,|ğœ™^2_ğ‘4ğ‘3âŸ©,</span>
        <span class="c1">#           ...</span>
        <span class="c1">#           ...,|ğœ™^0_ğ‘2^Nğ‘(2^N-2)âŸ©,|ğœ™^2_ğ‘2^Nğ‘(2^N-2)âŸ©,|ğœ™^0_ğ‘2^Nğ‘(2^N-1)âŸ©,|ğœ™^2_ğ‘2^Nğ‘(2^N-1)âŸ©]</span>
        <span class="c1">#</span>
        <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tensor_circuits_u</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_superposition_circuits_u</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="n">_construct_stateprep_circuits</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ansatz</span><span class="o">.</span><span class="n">bitstrings_u</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ansatz</span><span class="o">.</span><span class="n">bitstrings_are_symmetric</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tensor_circuits_v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_superposition_circuits_v</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_tensor_circuits_u</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_superposition_circuits_u</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_tensor_circuits_v</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_superposition_circuits_v</span><span class="p">,</span>
            <span class="p">)</span> <span class="o">=</span> <span class="n">_construct_stateprep_circuits</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ansatz</span><span class="o">.</span><span class="n">bitstrings_v</span>  <span class="c1"># type: ignore</span>
            <span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ansatz</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">EntanglementForgingAnsatz</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Property function for the ansatz.</span>

<span class="sd">        Returns:</span>
<span class="sd">            - (EntanglementForgingAnsatz): the ansatz member variable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ansatz</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">backend_names</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        List of backend names to be used.</span>

<span class="sd">        Returns:</span>
<span class="sd">            - (list[str]): the backend_names member variable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_backend_names</span>

    <span class="nd">@backend_names</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">backend_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">backend_names</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Change the backend_names class field.</span>

<span class="sd">        Args:</span>
<span class="sd">            - backend_names (list[str]): the list of backends to use</span>

<span class="sd">        Returns:</span>
<span class="sd">            - None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">backend_names</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_backend_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">backend_names</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_backend_names</span> <span class="o">=</span> <span class="n">backend_names</span>
        <span class="k">if</span> <span class="n">backend_names</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_session_ids</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">backend_names</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">options</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Options</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        List of options to be used.</span>

<span class="sd">        Returns:</span>
<span class="sd">            - (list[Options]): the options member variable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_options</span>

    <span class="nd">@options</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">options</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">options</span><span class="p">:</span> <span class="n">Options</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">Options</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Change the options class field.</span>

<span class="sd">        Args:</span>
<span class="sd">            - options (list[Options]): the list of options to use</span>

<span class="sd">        Returns:</span>
<span class="sd">            - None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="n">Options</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_options</span> <span class="o">=</span> <span class="p">[</span><span class="n">options</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_options</span> <span class="o">=</span> <span class="n">options</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">service</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">QiskitRuntimeService</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Property function for service class field.</span>

<span class="sd">        Returns:</span>
<span class="sd">            - (QiskitRuntimeService): the service member variable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">QiskitRuntimeService</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_service</span><span class="p">)</span>

    <span class="nd">@service</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">service</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">service</span><span class="p">:</span> <span class="n">QiskitRuntimeService</span> <span class="o">|</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Change the service class field.</span>

<span class="sd">        Args:</span>
<span class="sd">            - service (QiskitRuntimeService): the service used to spawn Qiskit primitives</span>

<span class="sd">        Returns:</span>
<span class="sd">            - None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_service</span> <span class="o">=</span> <span class="n">service</span><span class="o">.</span><span class="n">active_account</span><span class="p">()</span> <span class="k">if</span> <span class="n">service</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">service</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ansatz_parameters</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
        <span class="n">forged_operator</span><span class="p">:</span> <span class="n">EntanglementForgingOperator</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculate the energy.</span>

<span class="sd">        Computes âŸ¨HâŸ© - the energy value and the Schmidt matrix, $h_{n, m}$, given</span>
<span class="sd">        some ansatz parameter values.</span>

<span class="sd">        $h_{n, n} = \sum_{a, b} w_{a, b} \left [ \lambda_n^2 \langle b_n | U^t P_a U | b_n \rangle</span>
<span class="sd">            \langle b_n | V^t P_b V | b_n \rangle \right ]$</span>

<span class="sd">        $h_{n, m} = \sum_{a, b} w_{a, b} \left [ \lambda_n \lambda_m \sum_{p \in 4} -1^p \langle \phi^p_{b_n, b_m}</span>
<span class="sd">            | U^t P_a U | \phi^p_{b_n, b_m} \rangle \langle  \phi^p_{b_n, b_m} | V^t P_b V |  \phi^p_{b_n, b_m} \rangle \right ]$</span>

<span class="sd">        Energy = $ \sum_{n=1}^{2^N} \left ( h_{n, n} + \sum_{m=1}^{n-1} h_{n, m} \right ) $</span>

<span class="sd">        For now, we are only using $p \in \{0, 2 \} $ as opposed to $ p \in \{ 0, 1, 2, 3 \} $.</span>

<span class="sd">        Additionally, U = V is currently required, but may change in future versions.</span>

<span class="sd">        Args:</span>
<span class="sd">            - self</span>
<span class="sd">            - ansatz_parameters (Sequence[float]): the parameters to be used by the ansatz circuit,</span>
<span class="sd">                must be the same length as the circuit&#39;s parameters</span>
<span class="sd">            - forged_operator (EntanglementForgingOperator): the operator to forge the expectation</span>
<span class="sd">                value from</span>

<span class="sd">        Returns:</span>
<span class="sd">            - (tuple[float, np.ndarray, np.ndarray]): a tuple</span>
<span class="sd">                containing the energy (i.e. forged expectation value), the Schmidt coefficients,</span>
<span class="sd">                and the full Schmidt decomposition matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_backend_names</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_options</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_backend_names</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_options</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_options</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_options</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_options</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_backend_names</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;The list of backend names is length (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_backend_names</span><span class="p">)</span><span class="si">}</span><span class="s2">), but the list of options is length (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_options</span><span class="p">)</span><span class="si">}</span><span class="s2">). It is ambiguous how to combine the options with the backends.&quot;</span>
                    <span class="p">)</span>
        <span class="c1"># For now, we only assign the parameters to a copy of the ansatz</span>
        <span class="n">circuit_u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ansatz</span><span class="o">.</span><span class="n">circuit_u</span><span class="o">.</span><span class="n">bind_parameters</span><span class="p">(</span><span class="n">ansatz_parameters</span><span class="p">)</span>

        <span class="c1"># Create the tensor and superposition stateprep circuits</span>
        <span class="c1"># tensor_ansatze   = [U|biâŸ©      for |biâŸ©       in  tensor_circuits]</span>
        <span class="c1"># superposition_ansatze = [U|ğœ™^ğ‘_ğ‘ğ‘›ğ‘ğ‘šâŸ© for |ğœ™^ğ‘_ğ‘ğ‘›ğ‘ğ‘šâŸ© in superposition_circuits]</span>
        <span class="n">tensor_ansatze_u</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">prep_circ</span><span class="o">.</span><span class="n">compose</span><span class="p">(</span><span class="n">circuit_u</span><span class="p">)</span> <span class="k">for</span> <span class="n">prep_circ</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tensor_circuits_u</span>
        <span class="p">]</span>
        <span class="n">superposition_ansatze_u</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">prep_circ</span><span class="o">.</span><span class="n">compose</span><span class="p">(</span><span class="n">circuit_u</span><span class="p">)</span> <span class="k">for</span> <span class="n">prep_circ</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_superposition_circuits_u</span>
        <span class="p">]</span>

        <span class="n">tensor_ansatze_v</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">superposition_ansatze_v</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ansatz</span><span class="o">.</span><span class="n">bitstrings_are_symmetric</span><span class="p">:</span>
            <span class="n">tensor_ansatze_v</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">prep_circ</span><span class="o">.</span><span class="n">compose</span><span class="p">(</span><span class="n">circuit_u</span><span class="p">)</span> <span class="k">for</span> <span class="n">prep_circ</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tensor_circuits_v</span>
            <span class="p">]</span>
            <span class="n">superposition_ansatze_v</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">prep_circ</span><span class="o">.</span><span class="n">compose</span><span class="p">(</span><span class="n">circuit_u</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">prep_circ</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_superposition_circuits_v</span>
            <span class="p">]</span>

        <span class="c1"># Partition the expectation values for parallel calculation</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_backend_names</span><span class="p">:</span>
            <span class="n">num_partitions</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_backend_names</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">num_partitions</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="n">tensor_ansatze</span> <span class="o">=</span> <span class="n">tensor_ansatze_u</span> <span class="o">+</span> <span class="n">tensor_ansatze_v</span>
        <span class="n">superposition_ansatze</span> <span class="o">=</span> <span class="n">superposition_ansatze_u</span> <span class="o">+</span> <span class="n">superposition_ansatze_v</span>

        <span class="n">partitioned_tensor_ansatze</span> <span class="o">=</span> <span class="n">_partition</span><span class="p">(</span><span class="n">tensor_ansatze</span><span class="p">,</span> <span class="n">num_partitions</span><span class="p">)</span>
        <span class="n">partitioned_superposition_ansatze</span> <span class="o">=</span> <span class="n">_partition</span><span class="p">(</span>
            <span class="n">superposition_ansatze</span><span class="p">,</span> <span class="n">num_partitions</span>
        <span class="p">)</span>

        <span class="c1"># Get the RuntimeService as a hashable dictionary</span>
        <span class="n">service_args</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_service</span><span class="p">:</span>
            <span class="n">service_args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_service</span>

        <span class="n">session_ids</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_session_ids</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">session_ids</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_partitions</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">session_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_session_ids</span>

        <span class="n">partitioned_expval_futures</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">with</span> <span class="n">ThreadPoolExecutor</span><span class="p">()</span> <span class="k">as</span> <span class="n">executor</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">partition_index</span><span class="p">,</span> <span class="p">(</span>
                <span class="n">tensor_ansatze_partition</span><span class="p">,</span>
                <span class="n">superposition_ansatze_partition</span><span class="p">,</span>
            <span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                <span class="nb">zip</span><span class="p">(</span><span class="n">partitioned_tensor_ansatze</span><span class="p">,</span> <span class="n">partitioned_superposition_ansatze</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="n">backend_name</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="kc">None</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_backend_names</span> <span class="ow">is</span> <span class="kc">None</span>
                    <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_backend_names</span><span class="p">[</span><span class="n">partition_index</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">options</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="kc">None</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_options</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_options</span><span class="p">[</span><span class="n">partition_index</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">tensor_pauli_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">forged_operator</span><span class="o">.</span><span class="n">tensor_paulis</span><span class="p">)</span>
                <span class="n">superposition_pauli_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">forged_operator</span><span class="o">.</span><span class="n">superposition_paulis</span><span class="p">)</span>
                <span class="n">partitioned_expval_futures</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">executor</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span>
                        <span class="n">_estimate_expvals</span><span class="p">,</span>
                        <span class="n">tensor_ansatze_partition</span><span class="p">,</span>
                        <span class="n">tensor_pauli_list</span><span class="p">,</span>
                        <span class="n">superposition_ansatze_partition</span><span class="p">,</span>
                        <span class="n">superposition_pauli_list</span><span class="p">,</span>
                        <span class="n">service_args</span><span class="p">,</span>
                        <span class="n">backend_name</span><span class="p">,</span>
                        <span class="n">options</span><span class="p">,</span>
                        <span class="n">session_ids</span><span class="p">[</span><span class="n">partition_index</span><span class="p">],</span>
                    <span class="p">)</span>
                <span class="p">)</span>

        <span class="n">tensor_expvals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">superposition_expvals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">partitioned_expval_future</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">partitioned_expval_futures</span><span class="p">):</span>
            <span class="p">(</span>
                <span class="n">partition_tensor_expvals</span><span class="p">,</span>
                <span class="n">partition_superposition_expvals</span><span class="p">,</span>
                <span class="n">job_id</span><span class="p">,</span>
            <span class="p">)</span> <span class="o">=</span> <span class="n">partitioned_expval_future</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
            <span class="n">tensor_expvals</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">partition_tensor_expvals</span><span class="p">)</span>
            <span class="n">superposition_expvals</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">partition_superposition_expvals</span><span class="p">)</span>
            <span class="c1"># Start a session for each thread if this is the first run</span>
            <span class="k">if</span> <span class="n">job_id</span> <span class="ow">and</span> <span class="p">(</span><span class="n">session_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_session_ids</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Something unexpected happened. The session_ids field must be set when a job_id is present.&quot;</span>
                    <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_session_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">job_id</span>

        <span class="c1"># Compute the Schmidt matrix</span>
        <span class="n">h_schmidt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_h_schmidt</span><span class="p">(</span>
            <span class="n">forged_operator</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tensor_expvals</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">superposition_expvals</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">evals</span><span class="p">,</span> <span class="n">evecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">h_schmidt</span><span class="p">)</span>
        <span class="n">schmidt_coeffs</span> <span class="o">=</span> <span class="n">evecs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">energy</span> <span class="o">=</span> <span class="n">evals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">energy</span><span class="p">,</span> <span class="n">schmidt_coeffs</span><span class="p">,</span> <span class="n">h_schmidt</span>

    <span class="k">def</span> <span class="nf">_compute_h_schmidt</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">forged_operator</span><span class="p">:</span> <span class="n">EntanglementForgingOperator</span><span class="p">,</span>
        <span class="n">tensor_expvals</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">superpos_expvals</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the Schmidt decomposition of the Hamiltonian.</span>

<span class="sd">        Args:</span>
<span class="sd">            - forged_operator (EntanglementForgingOperator): the operator that the</span>
<span class="sd">                forged expectation values are computed with</span>
<span class="sd">            - tensor_expvals (np.ndarray): the expectation values</span>
<span class="sd">                for the tensor circuits (i.e. same Schmidt coefficients)</span>
<span class="sd">            - superpos_expvals (np.ndarray): the expectation values</span>
<span class="sd">                for the superposition circuits (i.e. different Schmidt coefficients)</span>

<span class="sd">        Returns:</span>
<span class="sd">           - (np.ndarray): the Schmidt matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Calculate the diagonal entries of the Schmidt matrix by</span>
        <span class="c1"># summing the expectation values associated with the tensor terms</span>
        <span class="c1"># hğ‘›ğ‘› = Î£_ab ğ‘¤ğ‘ğ‘â€¢[ ğœ†ğ‘›^2â€¢âŸ¨bğ‘›|U^tâ€¢Pğ‘â€¢U|bğ‘›âŸ©âŸ¨bğ‘›|V^tâ€¢Pğ‘â€¢V|bğ‘›âŸ© ]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ansatz</span><span class="o">.</span><span class="n">bitstrings_are_symmetric</span><span class="p">:</span>
            <span class="n">h_schmidt_diagonal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span>
                <span class="s2">&quot;ij, xi, xj-&gt;x&quot;</span><span class="p">,</span>
                <span class="n">forged_operator</span><span class="o">.</span><span class="n">w_ij</span><span class="p">,</span>  <span class="c1"># type: ignore</span>
                <span class="n">tensor_expvals</span><span class="p">,</span>
                <span class="n">tensor_expvals</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">num_tensor_terms</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">tensor_expvals</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">h_schmidt_diagonal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span>
                <span class="s2">&quot;ij, xi, xj-&gt;x&quot;</span><span class="p">,</span>
                <span class="n">forged_operator</span><span class="o">.</span><span class="n">w_ij</span><span class="p">,</span>  <span class="c1"># type: ignore</span>
                <span class="n">tensor_expvals</span><span class="p">[:</span><span class="n">num_tensor_terms</span><span class="p">,</span> <span class="p">:],</span>
                <span class="n">tensor_expvals</span><span class="p">[</span><span class="n">num_tensor_terms</span><span class="p">:,</span> <span class="p">:],</span>
            <span class="p">)</span>
        <span class="n">h_schmidt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">h_schmidt_diagonal</span><span class="p">)</span>

        <span class="c1"># Including the +/-Y superpositions would increase this to 4</span>
        <span class="n">num_lin_combos</span> <span class="o">=</span> <span class="mi">2</span>

        <span class="c1"># superpos_ansatze[2i]   = U|ğœ™^0_ğ‘ğ‘›ğ‘ğ‘šâŸ©</span>
        <span class="c1"># superpos_expvals[2i]   = [âŸ¨ğœ™^0_ğ‘ğ‘›ğ‘ğ‘š|U^tâ€¢ğ‘ƒğ‘â€¢U|ğœ™^0_ğ‘ğ‘›ğ‘ğ‘šâŸ© for ğ‘ƒğ‘ in superpos_paulis]</span>
        <span class="c1"># superpos_expvals[2i+1] = [âŸ¨ğœ™^1_ğ‘ğ‘›ğ‘ğ‘š|U^tâ€¢ğ‘ƒğ‘â€¢U|ğœ™^1_ğ‘ğ‘›ğ‘ğ‘šâŸ© for ğ‘ƒğ‘ in superpos_paulis]</span>
        <span class="n">superpos_expvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">superpos_expvals</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ansatz</span><span class="o">.</span><span class="n">bitstrings_are_symmetric</span><span class="p">:</span>
            <span class="n">p_plus_x</span> <span class="o">=</span> <span class="n">superpos_expvals</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="n">num_lin_combos</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">p_minus_x</span> <span class="o">=</span> <span class="n">superpos_expvals</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="n">num_lin_combos</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">p_delta_x_u</span> <span class="o">=</span> <span class="n">p_plus_x</span> <span class="o">-</span> <span class="n">p_minus_x</span>
            <span class="n">p_delta_x_v</span> <span class="o">=</span> <span class="n">p_delta_x_u</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">num_superpos_terms</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">superpos_expvals</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">pvss_u</span> <span class="o">=</span> <span class="n">superpos_expvals</span><span class="p">[:</span><span class="n">num_superpos_terms</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">pvss_v</span> <span class="o">=</span> <span class="n">superpos_expvals</span><span class="p">[</span><span class="n">num_superpos_terms</span><span class="p">:,</span> <span class="p">:]</span>

            <span class="n">p_plus_x_u</span> <span class="o">=</span> <span class="n">pvss_u</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="n">num_lin_combos</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">p_minus_x_u</span> <span class="o">=</span> <span class="n">pvss_u</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="n">num_lin_combos</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">p_delta_x_u</span> <span class="o">=</span> <span class="n">p_plus_x_u</span> <span class="o">-</span> <span class="n">p_minus_x_u</span>

            <span class="n">p_plus_x_v</span> <span class="o">=</span> <span class="n">pvss_v</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="n">num_lin_combos</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">p_minus_x_v</span> <span class="o">=</span> <span class="n">pvss_v</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="n">num_lin_combos</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">p_delta_x_v</span> <span class="o">=</span> <span class="n">p_plus_x_v</span> <span class="o">-</span> <span class="n">p_minus_x_v</span>

        <span class="c1"># Calculate and assign the off-diagonal values of the Schmidt matrix by</span>
        <span class="c1"># summing the expectation values associated with the superpos terms</span>
        <span class="n">h_schmidt_off_diagonals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span>
            <span class="s2">&quot;ab,xa,xb-&gt;x&quot;</span><span class="p">,</span> <span class="n">forged_operator</span><span class="o">.</span><span class="n">w_ab</span><span class="p">,</span> <span class="n">p_delta_x_u</span><span class="p">,</span> <span class="n">p_delta_x_v</span>  <span class="c1"># type: ignore</span>
        <span class="p">)</span>
        <span class="c1"># Create off diagonal index list</span>
        <span class="n">superpos_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ansatz</span><span class="o">.</span><span class="n">subspace_dimension</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ansatz</span><span class="o">.</span><span class="n">subspace_dimension</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">superpos_indices</span> <span class="o">+=</span> <span class="p">[(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)]</span>

        <span class="c1"># hğ‘›ğ‘š = Î£_ab ğ‘¤ğ‘ğ‘ â€¢[ ğœ†ğ‘›ğœ†ğ‘šâ€¢Î£_ğ‘âˆˆâ„¤4 -1^ğ‘â€¢âŸ¨ğœ™^ğ‘_ğ‘ğ‘›ğ‘ğ‘š|U^tâ€¢ğ‘ƒğ‘â€¢U|ğœ™^ğ‘_ğ‘ğ‘›ğ‘ğ‘šâŸ©â€¢</span>
        <span class="c1">#                                   âŸ¨ğœ™^ğ‘_ğ‘ğ‘›ğ‘ğ‘š|V^tâ€¢ğ‘ƒğ‘â€¢V|ğœ™^ğ‘_ğ‘ğ‘›ğ‘ğ‘šâŸ© ]</span>
        <span class="k">for</span> <span class="n">element</span><span class="p">,</span> <span class="n">indices</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">h_schmidt_off_diagonals</span><span class="p">,</span> <span class="n">superpos_indices</span><span class="p">):</span>
            <span class="n">h_schmidt</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">element</span>

        <span class="k">return</span> <span class="n">h_schmidt</span>

    <span class="k">def</span> <span class="nf">close_sessions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Close all the sessions opened by this object.</span>

<span class="sd">        Args:</span>
<span class="sd">            - None</span>

<span class="sd">        Returns:</span>
<span class="sd">            - None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_session_ids</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">session_id</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_session_ids</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_backend_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;There was a problem closing session id (</span><span class="si">{</span><span class="n">session_id</span><span class="si">}</span><span class="s2">). No backend to associate with session.&quot;</span>
                    <span class="p">)</span>
                <span class="n">session</span> <span class="o">=</span> <span class="n">Session</span><span class="p">(</span><span class="n">service</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">service</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_backend_names</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">session</span><span class="o">.</span><span class="n">_session_id</span> <span class="o">=</span> <span class="n">session_id</span>
                <span class="n">session</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="k">return</span></div>


<span class="k">def</span> <span class="nf">_construct_stateprep_circuits</span><span class="p">(</span>
    <span class="n">bitstrings</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]],</span>
    <span class="n">subsystem_id</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">QuantumCircuit</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="n">QuantumCircuit</span><span class="p">]]:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Prepare all circuits.</span>

<span class="sd">    Function to make the state preparation circuits. This constructs a set</span>
<span class="sd">    of circuits $ | b_n \rangle $ and $ | \phi^{p}_{n, m} \rangle $.</span>

<span class="sd">    The circuits $ | b_n \rangle $ are computational basis states specified by</span>
<span class="sd">    bitstrings $ b_n $, while the circuits $ | \phi^{p}_{n, m} \rangle $ are</span>
<span class="sd">    superpositions over pairs of bitstrings:</span>

<span class="sd">    $ | \phi^{p}_{n, m} \rangle = (| b_n \rangle + i^p | b_m \rangle) / \sqrt{2} $,</span>
<span class="sd">    as defined in &lt;https://arxiv.org/abs/2104.10220&gt;. Note that the output</span>
<span class="sd">    scaling (for the square root) is done in the estimator function.</span>

<span class="sd">    Example:</span>
<span class="sd">    _construct_stateprep_circuits([[0, 1], [1, 0]]) yields:</span>

<span class="sd">    bs0</span>
<span class="sd">    q_0: â”€â”€â”€â”€â”€</span>
<span class="sd">         â”Œâ”€â”€â”€â”</span>
<span class="sd">    q_1: â”¤ X â”œ</span>
<span class="sd">         â””â”€â”€â”€â”˜</span>
<span class="sd">    bs1</span>
<span class="sd">         â”Œâ”€â”€â”€â”</span>
<span class="sd">    q_0: â”¤ X â”œ</span>
<span class="sd">         â””â”€â”€â”€â”˜</span>
<span class="sd">    q_1: â”€â”€â”€â”€â”€</span>

<span class="sd">    bs0bs1xplus</span>
<span class="sd">         â”Œâ”€â”€â”€â”</span>
<span class="sd">    q_0: â”¤ H â”œâ”€â”€â– â”€â”€</span>
<span class="sd">         â”œâ”€â”€â”€â”¤â”Œâ”€â”´â”€â”</span>
<span class="sd">    q_1: â”¤ X â”œâ”¤ X â”œ</span>
<span class="sd">         â””â”€â”€â”€â”˜â””â”€â”€â”€â”˜</span>
<span class="sd">    bs0bs1xmin</span>
<span class="sd">         â”Œâ”€â”€â”€â”â”Œâ”€â”€â”€â”</span>
<span class="sd">    q_0: â”¤ H â”œâ”¤ Z â”œâ”€â”€â– â”€â”€</span>
<span class="sd">         â”œâ”€â”€â”€â”¤â””â”€â”€â”€â”˜â”Œâ”€â”´â”€â”</span>
<span class="sd">    q_1: â”¤ X â”œâ”€â”€â”€â”€â”€â”¤ X â”œ</span>
<span class="sd">         â””â”€â”€â”€â”˜     â””â”€â”€â”€â”˜</span>
<span class="sd">    bs1bs0xplus</span>
<span class="sd">         â”Œâ”€â”€â”€â”</span>
<span class="sd">    q_0: â”¤ H â”œâ”€â”€â– â”€â”€</span>
<span class="sd">         â”œâ”€â”€â”€â”¤â”Œâ”€â”´â”€â”</span>
<span class="sd">    q_1: â”¤ X â”œâ”¤ X â”œ</span>
<span class="sd">         â””â”€â”€â”€â”˜â””â”€â”€â”€â”˜</span>
<span class="sd">    bs1bs0xmin</span>
<span class="sd">         â”Œâ”€â”€â”€â”â”Œâ”€â”€â”€â”</span>
<span class="sd">    q_0: â”¤ H â”œâ”¤ Z â”œâ”€â”€â– â”€â”€</span>
<span class="sd">         â”œâ”€â”€â”€â”¤â””â”€â”€â”€â”˜â”Œâ”€â”´â”€â”</span>
<span class="sd">    q_1: â”¤ X â”œâ”€â”€â”€â”€â”€â”¤ X â”œ</span>
<span class="sd">         â””â”€â”€â”€â”˜     â””â”€â”€â”€â”˜</span>

<span class="sd">    Args:</span>
<span class="sd">        - bitstrings (list[tuple[int, ...]]): the input list of bitstrings used to generate the state preparation circuits</span>
<span class="sd">        - subsystem_id (str | None): the subsystem the bitstring reflects (&quot;u&quot; or &quot;v&quot;)</span>

<span class="sd">    Returns:</span>
<span class="sd">        - (tuple[list[QuantumCircuit], list[QuantumCircuit]]): A tuple containing the tensor (i.e., non-superposition</span>
<span class="sd">            or bitstring) circuits in the first index (length = len(bitstrings)) and the super-position circuits</span>
<span class="sd">            as the second element</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># If empty, just return</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">bitstrings</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[],</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">subsystem_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">subsystem_id</span> <span class="o">=</span> <span class="s2">&quot;u&quot;</span>
    <span class="c1"># If the spin-up and spin-down spin orbitals are together a 2*N qubit system,</span>
    <span class="c1"># the bitstring should be N bits long.</span>
    <span class="n">bitstring_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">bitstrings</span><span class="p">)</span>
    <span class="n">tensor_prep_circuits</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">_prepare_bitstring</span><span class="p">(</span><span class="n">bs</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;bs</span><span class="si">{</span><span class="n">subsystem_id</span><span class="si">}{</span><span class="nb">str</span><span class="p">(</span><span class="n">bs_idx</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">bs_idx</span><span class="p">,</span> <span class="n">bs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bitstring_array</span><span class="p">)</span>
    <span class="p">]</span>

    <span class="n">superpos_prep_circuits</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># Create superposition circuits for each bitstring pair</span>
    <span class="k">for</span> <span class="n">bs1_idx</span><span class="p">,</span> <span class="n">bs1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bitstring_array</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">bs2_idx</span><span class="p">,</span> <span class="n">bs2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bitstring_array</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">bs1_idx</span> <span class="o">==</span> <span class="n">bs2_idx</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">diffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">bs1</span> <span class="o">!=</span> <span class="n">bs2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">diffs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">diffs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">bs1</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">bs2</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">bs1</span>

                <span class="c1"># Find the first position the bitstrings differ and place a</span>
                <span class="c1"># hadamard in that position</span>
                <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">diffs</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">qcirc</span> <span class="o">=</span> <span class="n">_prepare_bitstring</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">x</span><span class="p">[:</span><span class="n">i</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:])))</span>
                <span class="n">qcirc</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

                <span class="c1"># Create a superposition circuit for each psi value in {0, 2}</span>
                <span class="n">psi_xplus</span><span class="p">,</span> <span class="n">psi_xmin</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">qcirc</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span>
                        <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;bs</span><span class="si">{</span><span class="n">subsystem_id</span><span class="si">}{</span><span class="n">bs1_idx</span><span class="si">}</span><span class="s2">bs</span><span class="si">{</span><span class="n">subsystem_id</span><span class="si">}{</span><span class="n">bs2_idx</span><span class="si">}{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;xplus&quot;</span><span class="p">,</span> <span class="s2">&quot;xmin&quot;</span><span class="p">]</span>
                <span class="p">]</span>
                <span class="n">psi_xmin</span><span class="o">.</span><span class="n">z</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">psi</span> <span class="ow">in</span> <span class="p">[</span><span class="n">psi_xplus</span><span class="p">,</span> <span class="n">psi_xmin</span><span class="p">]:</span>
                    <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">S</span><span class="p">:</span>
                        <span class="n">psi</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
                    <span class="n">superpos_prep_circuits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span>

            <span class="c1"># If the two bitstrings are equivalent (i.e. bn==bm)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">qcirc</span> <span class="o">=</span> <span class="n">_prepare_bitstring</span><span class="p">(</span>
                    <span class="n">bs1</span><span class="p">,</span>
                    <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;bs</span><span class="si">{</span><span class="n">subsystem_id</span><span class="si">}{</span><span class="n">bs1_idx</span><span class="si">}</span><span class="s2">bs</span><span class="si">{</span><span class="n">subsystem_id</span><span class="si">}{</span><span class="n">bs2_idx</span><span class="si">}</span><span class="s2">_hybrid_&quot;</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">psi_xplus</span><span class="p">,</span> <span class="n">psi_xmin</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">qcirc</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">qcirc</span><span class="o">.</span><span class="n">name</span><span class="si">}{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;xplus&quot;</span><span class="p">,</span> <span class="s2">&quot;xmin&quot;</span><span class="p">]</span>
                <span class="p">]</span>
                <span class="n">superpos_prep_circuits</span> <span class="o">+=</span> <span class="p">[</span><span class="n">psi_xplus</span><span class="p">,</span> <span class="n">psi_xmin</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">tensor_prep_circuits</span><span class="p">,</span> <span class="n">superpos_prep_circuits</span>


<span class="k">def</span> <span class="nf">_prepare_bitstring</span><span class="p">(</span>
    <span class="n">bitstring</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">QuantumCircuit</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Prepare the bitstring circuits.</span>

<span class="sd">    Generate a computational basis state from the input bitstring by applying an X gate to</span>
<span class="sd">    every qubit that has a 1 in the bitstring.</span>

<span class="sd">    Args:</span>
<span class="sd">        - bitstring (np.ndarray | tuple[int, ...]): the container for the</span>
<span class="sd">            bitstring information. Must contain 0s and 1s and the 1s are used to determine</span>
<span class="sd">            where to put the X gates</span>
<span class="sd">        - name (str, optional): the name of the circuit</span>

<span class="sd">    Returns:</span>
<span class="sd">        - (QuantumCircuit): the prepared circuit</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">qcirc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bitstring</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">qb_idx</span><span class="p">,</span> <span class="n">bit</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bitstring</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">bit</span><span class="p">:</span>
            <span class="n">qcirc</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="n">qb_idx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">qcirc</span>


<span class="k">def</span> <span class="nf">_partition</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Partitions the input.</span>

<span class="sd">    Function that partitions the input, a, into a generator containing</span>
<span class="sd">    n sub-partitions of a (that are the same type as a).</span>
<span class="sd">    Example:</span>
<span class="sd">    _partition([1, 2, 3], 2) -&gt; (i for i in [[1, 2], [3]])</span>

<span class="sd">    Args:</span>
<span class="sd">        - a (iterable): an object with length and indexing to be partitioned</span>
<span class="sd">        - n (int): the number of partitions</span>
<span class="sd">    Returns:</span>
<span class="sd">        - (generator): the generator containing the paritions</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">k</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">n</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">k</span> <span class="o">+</span> <span class="nb">min</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="p">:</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">k</span> <span class="o">+</span> <span class="nb">min</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">)]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_estimate_expvals</span><span class="p">(</span>
    <span class="n">tensor_ansatze</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">QuantumCircuit</span><span class="p">],</span>
    <span class="n">tensor_paulis</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Pauli</span><span class="p">],</span>
    <span class="n">superposition_ansatze</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">QuantumCircuit</span><span class="p">],</span>
    <span class="n">superposition_paulis</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Pauli</span><span class="p">],</span>
    <span class="n">service_args</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">backend_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">options</span><span class="p">:</span> <span class="n">Options</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">session_id</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Run quantum circuits to generate the expectation values.</span>

<span class="sd">    Function to estimate the exepctation value of some observables on the</span>
<span class="sd">    tensor and superposition circuits used for reconstructing the full</span>
<span class="sd">    expectation value from the Schmidt decomposed circuit. The ray decorator</span>
<span class="sd">    indicates that this is an actor function (that runs its own python</span>
<span class="sd">    process).</span>

<span class="sd">    Args:</span>
<span class="sd">        - tensor_ansatze (list[QuantumCircuit]): the circuits that have the same</span>
<span class="sd">            Schmidt coefficient</span>
<span class="sd">        - tensor_paulis (list[Pauli]): the pauli operators to measure and calculate</span>
<span class="sd">            the expectation values from for the circuits with the same Schmidt coefficient</span>
<span class="sd">        - superposition_ansatze (list[QuantumCircuit]): the circuits with different</span>
<span class="sd">            Schmidt coefficients</span>
<span class="sd">        - superposition_paulis (list[Pauli]): the pauli operators to measure and calculate</span>
<span class="sd">            the expectation values from for the circuits with different Schmidt</span>
<span class="sd">            coefficients</span>
<span class="sd">        - service_args (dict[str, Any]): The service account used to spawn Qiskit primitives</span>
<span class="sd">        - backend_name (str): The backend to use to evaluate the grouped experiments</span>
<span class="sd">        - options (Options): The options to use with the backend</span>
<span class="sd">        - session_id (str): The session id to use when calling primitive programs</span>

<span class="sd">    Returns:</span>
<span class="sd">        - (tuple[list[np.ndarray], list[np.ndarray], str | None]): the expectation values for the</span>
<span class="sd">            tensor circuits and superposition circuits</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ansatz_t</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">QuantumCircuit</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">observables_t</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Pauli</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">circuit</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tensor_ansatze</span><span class="p">):</span>
        <span class="n">ansatz_t</span> <span class="o">+=</span> <span class="p">[</span><span class="n">circuit</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">tensor_paulis</span><span class="p">)</span>
        <span class="n">observables_t</span> <span class="o">+=</span> <span class="n">tensor_paulis</span>

    <span class="n">ansatz_s</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">QuantumCircuit</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">observables_s</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Pauli</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">circuit</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">superposition_ansatze</span><span class="p">):</span>
        <span class="n">ansatz_s</span> <span class="o">+=</span> <span class="p">[</span><span class="n">circuit</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">superposition_paulis</span><span class="p">)</span>
        <span class="n">observables_s</span> <span class="o">+=</span> <span class="n">superposition_paulis</span>

    <span class="n">all_ansatze_for_estimator</span> <span class="o">=</span> <span class="n">ansatz_t</span> <span class="o">+</span> <span class="n">ansatz_s</span>
    <span class="n">all_observables_for_estimator</span> <span class="o">=</span> <span class="n">observables_t</span> <span class="o">+</span> <span class="n">observables_s</span>

    <span class="c1"># ID for this job. If it is the first job for the knitter, it will become the session ID</span>
    <span class="n">job_id</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">service_args</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Set the backend. Default to runtime qasm simulator</span>
        <span class="k">if</span> <span class="n">backend_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;If passing a QiskitRuntimeService, a list of backend names must be specified.&quot;</span>
            <span class="p">)</span>
        <span class="n">service</span> <span class="o">=</span> <span class="n">QiskitRuntimeService</span><span class="p">(</span><span class="o">**</span><span class="n">service_args</span><span class="p">)</span>
        <span class="n">session</span> <span class="o">=</span> <span class="n">Session</span><span class="p">(</span><span class="n">service</span><span class="o">=</span><span class="n">service</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="n">backend_name</span><span class="p">)</span>
        <span class="n">session</span><span class="o">.</span><span class="n">_session_id</span> <span class="o">=</span> <span class="n">session_id</span>
        <span class="n">estimator</span> <span class="o">=</span> <span class="n">Estimator</span><span class="p">(</span><span class="n">session</span><span class="o">=</span><span class="n">session</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">)</span>

        <span class="n">job</span> <span class="o">=</span> <span class="n">estimator</span><span class="o">.</span><span class="n">run</span><span class="p">(</span>
            <span class="n">circuits</span><span class="o">=</span><span class="n">all_ansatze_for_estimator</span><span class="p">,</span>
            <span class="n">observables</span><span class="o">=</span><span class="n">all_observables_for_estimator</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># If a None result was returned, keep checking for a minute, then error out</span>
        <span class="c1"># This is necessary due to some unexplained behavior from runtime, which is causing valid</span>
        <span class="c1"># job results to be returned as None. These results often seem to be retrievable at a later time,</span>
        <span class="c1"># so we have hacked together this loop to try and prevent a crash of the program.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">job</span><span class="o">.</span><span class="n">result</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;A None result was returned from Qiskit Runtime (job id: </span><span class="si">{</span><span class="n">job</span><span class="o">.</span><span class="n">job_id</span><span class="si">}</span><span class="s2">). &quot;</span>
                <span class="s2">&quot;Waiting 3 seconds and querying again...&quot;</span>
            <span class="p">)</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;A None result was returned from Qiskit Runtime.&quot;</span><span class="p">)</span>

        <span class="n">results</span> <span class="o">=</span> <span class="n">job</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">values</span>

        <span class="n">job_id</span> <span class="o">=</span> <span class="n">job</span><span class="o">.</span><span class="n">job_id</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">estimator</span> <span class="o">=</span> <span class="n">TestEstimator</span><span class="p">()</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">estimator</span><span class="o">.</span><span class="n">run</span><span class="p">(</span>
                <span class="n">circuits</span><span class="o">=</span><span class="n">all_ansatze_for_estimator</span><span class="p">,</span>
                <span class="n">observables</span><span class="o">=</span><span class="n">all_observables_for_estimator</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="o">.</span><span class="n">result</span><span class="p">()</span>
            <span class="o">.</span><span class="n">values</span>
        <span class="p">)</span>

    <span class="c1"># Post-process the results to get our expectation values in the right format</span>
    <span class="n">num_tensor_expvals</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tensor_ansatze</span><span class="p">)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">tensor_paulis</span><span class="p">)</span>
    <span class="n">estimator_results_t</span> <span class="o">=</span> <span class="n">results</span><span class="p">[:</span><span class="n">num_tensor_expvals</span><span class="p">]</span>
    <span class="n">estimator_results_s</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="n">num_tensor_expvals</span><span class="p">:]</span>

    <span class="n">tensor_expval_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
        <span class="n">estimator_results_t</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">tensor_ansatze</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">tensor_paulis</span><span class="p">)))</span>
    <span class="p">)</span>
    <span class="n">superposition_expval_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
        <span class="n">estimator_results_s</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">superposition_ansatze</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">superposition_paulis</span><span class="p">))</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="c1"># Scale the superposition terms</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ansatz</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">superposition_ansatze</span><span class="p">):</span>
        <span class="c1"># Scale the expectation values to account for 1/sqrt(2) coefficients</span>
        <span class="k">if</span> <span class="s2">&quot;hybrid_xmin&quot;</span> <span class="ow">in</span> <span class="n">ansatz</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="n">superposition_expval_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="mf">0.0</span>
        <span class="k">elif</span> <span class="s2">&quot;hybrid_xplus&quot;</span> <span class="ow">in</span> <span class="n">ansatz</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">superposition_expval_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="mf">0.5</span>

    <span class="k">return</span> <span class="n">tensor_expval_list</span><span class="p">,</span> <span class="n">superposition_expval_list</span><span class="p">,</span> <span class="n">job_id</span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">Circuit Knitting Toolbox</a></h1>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installation Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../circuit_cutting/tutorials/index.html">Circuit Cutting Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../circuit_cutting/explanation/index.html">Circuit Cutting Explanatory Material</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../circuit_cutting/how-tos/index.html">Circuit Cutting How-To Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../circuit_cutting/cutqc/index.html">CutQC (legacy circuit cutting implementation)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../entanglement_forging/tutorials/index.html">Entanglement Forging Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../entanglement_forging/explanation/index.html">Entanglement Forging Explanatory Material</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../entanglement_forging/how-tos/index.html">Entanglement Forging How-To Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../apidocs/index.html">API References</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../release-notes.html">Release Notes</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.0.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
    </div>

    

    
  </body>
</html>