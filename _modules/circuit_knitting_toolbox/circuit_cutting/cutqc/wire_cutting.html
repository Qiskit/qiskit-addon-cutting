<!doctype html>
<html class="no-js" lang="en">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><link rel="index" title="Index" href="../../../../genindex.html" /><link rel="search" title="Search" href="../../../../search.html" />

    <!-- Generated with Sphinx 7.0.1 and Furo 2023.05.20 -->
        <title>circuit_knitting_toolbox.circuit_cutting.cutqc.wire_cutting - Circuit Knitting Toolbox 0.2.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../_static/styles/furo.css?digest=e6660623a769aa55fea372102b9bf3151b292993" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/styles/qiskit-sphinx-theme.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/jupyter-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/thebelab.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    
    


<style>
  body {
    --color-code-background: #ffffff;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style><link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;600&family=IBM+Plex+Sans:ital,wght@0,400;0,600;1,400;1,600&display=swap" rel="stylesheet">
<script src="../../../../_static/js/web-components/top-nav-bar.js"></script></head>
  <body>
    
    <script>document.body.dataset.theme = "light";</script>
    
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg id="icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32">
      <defs><style>.cls-1{fill:none;}</style></defs>
      <path d="M28,4H4A2,2,0,0,0,2,6V26a2,2,0,0,0,2,2H28a2,2,0,0,0,2-2V6A2,2,0,0,0,28,4ZM4,6H20V26H4ZM28,26H22V6h6Z"/>
      <rect id="_Transparent_Rectangle_" data-name="&lt;Transparent Rectangle&gt;" class="cls-1" width="32" height="32"/>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg version="1.1" id="icon" xmlns="http://www.w3.org/2000/svg" x="0px" y="0px"
         viewBox="0 0 32 32" style="enable-background:new 0 0 32 32;" xml:space="preserve"><polygon points="22,16 12,26 10.6,24.6 19.2,16 10.6,7.4 12,6 " stroke="currentColor"/>
      <rect id="_x3C_Transparent_Rectangle_x3E_" fill="none" width="32" height="32"/>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg><qiskit-ui-shell variant="hide-account"></qiskit-ui-shell><input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>Site contents <i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label>
    </div>
    <div class="header-center"></div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon no-toc" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><form class="sidebar-search-container" method="get" action="../../../../search.html" role="search">
  <input class="sidebar-search" placeholder="Search Circuit Knitting Toolbox docs" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../index.html">About Circuit Knitting Toolbox</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../install.html">Installation Instructions</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Circuit Cutting</span></p>
<ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../../circuit_cutting/tutorials/index.html">Cutting Tutorials</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle navigation of Cutting Tutorials</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../circuit_cutting/tutorials/01_gate_cutting_to_reduce_circuit_width.html">Gate Cutting to Reduce Circuit Width</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../circuit_cutting/tutorials/02_gate_cutting_to_reduce_circuit_depth.html">Gate Cutting to Reduce Circuit Depth</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../circuit_cutting/explanation/index.html">Cutting Explanatory Material</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../../circuit_cutting/how-tos/index.html">Cutting How-To Guides</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle navigation of Cutting How-To Guides</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../circuit_cutting/how-tos/how_to_generate_exact_quasi_dists_from_sampler.html">How to generate exact quasiprobability distributions from Sampler</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../circuit_cutting/how-tos/how_to_generate_exact_sampling_coefficients.html">How to generate exact sampling coefficients</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../../circuit_cutting/cutqc/index.html">CutQC (legacy circuit cutting implementation)</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><div class="visually-hidden">Toggle navigation of CutQC (legacy circuit cutting implementation)</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../circuit_cutting/cutqc/tutorials/tutorial_1_automatic_cut_finding.html">CutQC Tutorial 1: Circuit Cutting with Automatic Cut Finding</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../circuit_cutting/cutqc/tutorials/tutorial_2_manual_cutting.html">CutQC Tutorial 2: Circuit Cutting with Manual Wire Cutting</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../circuit_cutting/cutqc/tutorials/tutorial_3_cutting_with_quantum_serverless.html">CutQC Tutorial 3: Circuit Cutting with Quantum Serverless</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Entanglement Forging</span></p>
<ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../../entanglement_forging/tutorials/index.html">Forging Tutorials</a><input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" role="switch" type="checkbox"/><label for="toctree-checkbox-4"><div class="visually-hidden">Toggle navigation of Forging Tutorials</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../entanglement_forging/tutorials/tutorial_1_getting_started.html">Tutorial 1: Entanglement Forging for estimating the ground state energy of the H2 molecule</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../entanglement_forging/tutorials/tutorial_2_forging_with_quantum_serverless.html">Tutorial 2: Entanglement Forging with Quantum Serverless</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../entanglement_forging/explanation/index.html">Forging Explanatory Material</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../../entanglement_forging/how-tos/index.html">Forging How-To Guides</a><input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" role="switch" type="checkbox"/><label for="toctree-checkbox-5"><div class="visually-hidden">Toggle navigation of Forging How-To Guides</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../entanglement_forging/how-tos/specify-problem.html">How to specify the problem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../entanglement_forging/how-tos/use-asymmetric-bitstrings.html">How to use asymmetric bitstrings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../entanglement_forging/how-tos/freeze-orbitals.html">How to freeze orbitals</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">References</span></p>
<ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../../apidocs/index.html">API References</a><input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" role="switch" type="checkbox"/><label for="toctree-checkbox-6"><div class="visually-hidden">Toggle navigation of API References</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../../apidocs/circuit_cutting.html">Circuit Cutting</a><input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" role="switch" type="checkbox"/><label for="toctree-checkbox-7"><div class="visually-hidden">Toggle navigation of Circuit Cutting</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../stubs/circuit_knitting_toolbox.circuit_cutting.partition_circuit_qubits.html">circuit_knitting_toolbox.circuit_cutting.partition_circuit_qubits</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../stubs/circuit_knitting_toolbox.circuit_cutting.partition_problem.html">circuit_knitting_toolbox.circuit_cutting.partition_problem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../stubs/circuit_knitting_toolbox.circuit_cutting.decompose_gates.html">circuit_knitting_toolbox.circuit_cutting.decompose_gates</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../stubs/circuit_knitting_toolbox.circuit_cutting.execute_experiments.html">circuit_knitting_toolbox.circuit_cutting.execute_experiments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../stubs/circuit_knitting_toolbox.circuit_cutting.reconstruct_expectation_values.html">circuit_knitting_toolbox.circuit_cutting.reconstruct_expectation_values</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../stubs/circuit_knitting_toolbox.circuit_cutting.PartitionedCuttingProblem.html">circuit_knitting_toolbox.circuit_cutting.PartitionedCuttingProblem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../stubs/circuit_knitting_toolbox.circuit_cutting.CuttingExperimentResults.html">circuit_knitting_toolbox.circuit_cutting.CuttingExperimentResults</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../stubs/circuit_knitting_toolbox.circuit_cutting.qpd.QPDBasis.html">circuit_knitting_toolbox.circuit_cutting.qpd.QPDBasis</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../stubs/circuit_knitting_toolbox.circuit_cutting.qpd.BaseQPDGate.html">circuit_knitting_toolbox.circuit_cutting.qpd.BaseQPDGate</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../stubs/circuit_knitting_toolbox.circuit_cutting.qpd.SingleQubitQPDGate.html">circuit_knitting_toolbox.circuit_cutting.qpd.SingleQubitQPDGate</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../stubs/circuit_knitting_toolbox.circuit_cutting.qpd.TwoQubitQPDGate.html">circuit_knitting_toolbox.circuit_cutting.qpd.TwoQubitQPDGate</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../stubs/circuit_knitting_toolbox.circuit_cutting.qpd.WeightType.html">circuit_knitting_toolbox.circuit_cutting.qpd.WeightType</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../stubs/circuit_knitting_toolbox.circuit_cutting.qpd.generate_qpd_samples.html">circuit_knitting_toolbox.circuit_cutting.qpd.generate_qpd_samples</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../stubs/circuit_knitting_toolbox.circuit_cutting.qpd.decompose_qpd_instructions.html">circuit_knitting_toolbox.circuit_cutting.qpd.decompose_qpd_instructions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../stubs/circuit_knitting_toolbox.circuit_cutting.cutqc.run_subcircuit_instances.html">circuit_knitting_toolbox.circuit_cutting.cutqc.run_subcircuit_instances</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../stubs/circuit_knitting_toolbox.circuit_cutting.cutqc.generate_summation_terms.html">circuit_knitting_toolbox.circuit_cutting.cutqc.generate_summation_terms</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../stubs/circuit_knitting_toolbox.circuit_cutting.cutqc.build.html">circuit_knitting_toolbox.circuit_cutting.cutqc.build</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../stubs/circuit_knitting_toolbox.circuit_cutting.cutqc.verify.html">circuit_knitting_toolbox.circuit_cutting.cutqc.verify</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../stubs/circuit_knitting_toolbox.circuit_cutting.cutqc.cut_circuit_wires.html">circuit_knitting_toolbox.circuit_cutting.cutqc.cut_circuit_wires</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../stubs/circuit_knitting_toolbox.circuit_cutting.cutqc.evaluate_subcircuits.html">circuit_knitting_toolbox.circuit_cutting.cutqc.evaluate_subcircuits</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../stubs/circuit_knitting_toolbox.circuit_cutting.cutqc.reconstruct_full_distribution.html">circuit_knitting_toolbox.circuit_cutting.cutqc.reconstruct_full_distribution</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../../apidocs/entanglement_forging.html">Entanglement Forging</a><input class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" role="switch" type="checkbox"/><label for="toctree-checkbox-8"><div class="visually-hidden">Toggle navigation of Entanglement Forging</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../stubs/circuit_knitting_toolbox.entanglement_forging.EntanglementForgingKnitter.html">circuit_knitting_toolbox.entanglement_forging.EntanglementForgingKnitter</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../stubs/circuit_knitting_toolbox.entanglement_forging.EntanglementForgingOperator.html">circuit_knitting_toolbox.entanglement_forging.EntanglementForgingOperator</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../stubs/circuit_knitting_toolbox.entanglement_forging.EntanglementForgingAnsatz.html">circuit_knitting_toolbox.entanglement_forging.EntanglementForgingAnsatz</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../stubs/circuit_knitting_toolbox.entanglement_forging.EntanglementForgingGroundStateSolver.html">circuit_knitting_toolbox.entanglement_forging.EntanglementForgingGroundStateSolver</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../stubs/circuit_knitting_toolbox.entanglement_forging.cholesky_decomposition.html">circuit_knitting_toolbox.entanglement_forging.cholesky_decomposition</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../stubs/circuit_knitting_toolbox.entanglement_forging.convert_cholesky_operator.html">circuit_knitting_toolbox.entanglement_forging.convert_cholesky_operator</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../../apidocs/utils.html">Utilities</a><input class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" role="switch" type="checkbox"/><label for="toctree-checkbox-9"><div class="visually-hidden">Toggle navigation of Utilities</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../stubs/circuit_knitting_toolbox.utils.bitwise.bit_count.html">circuit_knitting_toolbox.utils.bitwise.bit_count</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../stubs/circuit_knitting_toolbox.utils.conversion.quasi_to_real.html">circuit_knitting_toolbox.utils.conversion.quasi_to_real</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../stubs/circuit_knitting_toolbox.utils.conversion.nearest_probability_distribution.html">circuit_knitting_toolbox.utils.conversion.nearest_probability_distribution</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../stubs/circuit_knitting_toolbox.utils.conversion.naive_probability_distribution.html">circuit_knitting_toolbox.utils.conversion.naive_probability_distribution</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../stubs/circuit_knitting_toolbox.utils.conversion.dict_to_array.html">circuit_knitting_toolbox.utils.conversion.dict_to_array</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../stubs/circuit_knitting_toolbox.utils.iteration.unique_by_id.html">circuit_knitting_toolbox.utils.iteration.unique_by_id</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../stubs/circuit_knitting_toolbox.utils.iteration.unique_by_eq.html">circuit_knitting_toolbox.utils.iteration.unique_by_eq</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../stubs/circuit_knitting_toolbox.utils.metrics.chi2_distance.html">circuit_knitting_toolbox.utils.metrics.chi2_distance</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../stubs/circuit_knitting_toolbox.utils.metrics.MSE.html">circuit_knitting_toolbox.utils.metrics.MSE</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../stubs/circuit_knitting_toolbox.utils.metrics.MAPE.html">circuit_knitting_toolbox.utils.metrics.MAPE</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../stubs/circuit_knitting_toolbox.utils.metrics.cross_entropy.html">circuit_knitting_toolbox.utils.metrics.cross_entropy</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../stubs/circuit_knitting_toolbox.utils.metrics.HOP.html">circuit_knitting_toolbox.utils.metrics.HOP</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../stubs/circuit_knitting_toolbox.utils.observable_grouping.observables_restricted_to_subsystem.html">circuit_knitting_toolbox.utils.observable_grouping.observables_restricted_to_subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../stubs/circuit_knitting_toolbox.utils.observable_grouping.CommutingObservableGroup.html">circuit_knitting_toolbox.utils.observable_grouping.CommutingObservableGroup</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../stubs/circuit_knitting_toolbox.utils.observable_grouping.ObservableCollection.html">circuit_knitting_toolbox.utils.observable_grouping.ObservableCollection</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../stubs/circuit_knitting_toolbox.utils.orbital_reduction.reduce_bitstrings.html">circuit_knitting_toolbox.utils.orbital_reduction.reduce_bitstrings</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../stubs/circuit_knitting_toolbox.utils.simulation.simulate_statevector_outcomes.html">circuit_knitting_toolbox.utils.simulation.simulate_statevector_outcomes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../stubs/circuit_knitting_toolbox.utils.simulation.ExactSampler.html">circuit_knitting_toolbox.utils.simulation.ExactSampler</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../stubs/circuit_knitting_toolbox.utils.transforms.separate_circuit.html">circuit_knitting_toolbox.utils.transforms.separate_circuit</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../stubs/circuit_knitting_toolbox.utils.transforms.SeparatedCircuits.html">circuit_knitting_toolbox.utils.transforms.SeparatedCircuits</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../release-notes.html">Release Notes</a></li>
</ul>

</div></div>
      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon no-toc" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <h1>Source code for circuit_knitting_toolbox.circuit_cutting.cutqc.wire_cutting</h1><div class="highlight"><pre>
<span></span><span class="c1"># This code is a Qiskit project.</span>

<span class="c1"># (C) Copyright IBM 2022.</span>

<span class="c1"># This code is licensed under the Apache License, Version 2.0. You may</span>
<span class="c1"># obtain a copy of this license in the LICENSE.txt file in the root directory</span>
<span class="c1"># of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.</span>
<span class="c1"># Any modifications or derivative works of this code must retain this</span>
<span class="c1"># copyright notice, and modified files need to carry a notice indicating</span>
<span class="c1"># that they have been altered from the originals.</span>

<span class="sd">&quot;&quot;&quot;Functions for conducting the wire cutting on quantum circuits.&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">cast</span><span class="p">,</span> <span class="n">no_type_check</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">qiskit</span> <span class="kn">import</span> <span class="n">QuantumCircuit</span><span class="p">,</span> <span class="n">QuantumRegister</span>
<span class="kn">from</span> <span class="nn">qiskit.circuit</span> <span class="kn">import</span> <span class="n">Qubit</span>
<span class="kn">from</span> <span class="nn">qiskit.dagcircuit</span> <span class="kn">import</span> <span class="n">DAGCircuit</span><span class="p">,</span> <span class="n">DAGOpNode</span>
<span class="kn">from</span> <span class="nn">qiskit.converters</span> <span class="kn">import</span> <span class="n">circuit_to_dag</span><span class="p">,</span> <span class="n">dag_to_circuit</span>
<span class="kn">from</span> <span class="nn">qiskit_ibm_runtime</span> <span class="kn">import</span> <span class="n">Options</span><span class="p">,</span> <span class="n">QiskitRuntimeService</span>

<span class="kn">from</span> <span class="nn">.wire_cutting_evaluation</span> <span class="kn">import</span> <span class="n">run_subcircuit_instances</span>
<span class="kn">from</span> <span class="nn">.wire_cutting_post_processing</span> <span class="kn">import</span> <span class="n">generate_summation_terms</span><span class="p">,</span> <span class="n">build</span>
<span class="kn">from</span> <span class="nn">.wire_cutting_verification</span> <span class="kn">import</span> <span class="n">generate_reconstructed_output</span>


<div class="viewcode-block" id="cut_circuit_wires"><a class="viewcode-back" href="../../../../stubs/circuit_knitting_toolbox.circuit_cutting.cutqc.cut_circuit_wires.html#circuit_knitting_toolbox.circuit_cutting.cutqc.cut_circuit_wires">[docs]</a><span class="k">def</span> <span class="nf">cut_circuit_wires</span><span class="p">(</span>
    <span class="n">circuit</span><span class="p">:</span> <span class="n">QuantumCircuit</span><span class="p">,</span>
    <span class="n">method</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">subcircuit_vertices</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">max_subcircuit_width</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">max_subcircuit_cuts</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">max_subcircuit_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">max_cuts</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">num_subcircuits</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Decompose the circuit into a collection of subcircuits.</span>

<span class="sd">    Args:</span>
<span class="sd">        method: Whether to have the cuts be &#39;automatically&#39; found, in a</span>
<span class="sd">            provably optimal way, or whether to &#39;manually&#39; specify the cuts</span>
<span class="sd">        subcircuit_vertices: The vertices to be used in the subcircuits. Note</span>
<span class="sd">            that these are not the indices of the qubits, but the nodes in the circuit DAG</span>
<span class="sd">        max_subcircuit_width: Max number of qubits in each subcircuit</span>
<span class="sd">        max_cuts: Max total number of cuts allowed</span>
<span class="sd">        num_subcircuits: List of number of subcircuits to try</span>
<span class="sd">        max_subcircuit_cuts: Max number of cuts for a subcircuit</span>
<span class="sd">        max_subcircuit_size: Max number of gates in a subcircuit</span>
<span class="sd">        verbose: Flag for printing output of cutting</span>

<span class="sd">    Returns:</span>
<span class="sd">        A dictionary containing information on the cuts, including the subcircuits</span>
<span class="sd">        themselves (key: &#39;subcircuits&#39;)</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: The input method does not match the other provided arguments</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cuts</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;automatic&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">max_subcircuit_width</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The max_subcircuit_width argument must be set if using automatic cut finding.&quot;</span>
            <span class="p">)</span>
        <span class="n">cuts</span> <span class="o">=</span> <span class="n">find_wire_cuts</span><span class="p">(</span>
            <span class="n">circuit</span><span class="o">=</span><span class="n">circuit</span><span class="p">,</span>
            <span class="n">max_subcircuit_width</span><span class="o">=</span><span class="n">max_subcircuit_width</span><span class="p">,</span>
            <span class="n">max_cuts</span><span class="o">=</span><span class="n">max_cuts</span><span class="p">,</span>
            <span class="n">num_subcircuits</span><span class="o">=</span><span class="n">num_subcircuits</span><span class="p">,</span>
            <span class="n">max_subcircuit_cuts</span><span class="o">=</span><span class="n">max_subcircuit_cuts</span><span class="p">,</span>
            <span class="n">max_subcircuit_size</span><span class="o">=</span><span class="n">max_subcircuit_size</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;manual&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">subcircuit_vertices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The subcircuit_vertices argument must be set if manually specifying cuts.&quot;</span>
            <span class="p">)</span>
        <span class="n">cuts</span> <span class="o">=</span> <span class="n">cut_circuit_wire</span><span class="p">(</span>
            <span class="n">circuit</span><span class="o">=</span><span class="n">circuit</span><span class="p">,</span> <span class="n">subcircuit_vertices</span><span class="o">=</span><span class="n">subcircuit_vertices</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;The method argument for the decompose method should be either &quot;automatic&quot; or &quot;manual&quot;.&#39;</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">cuts</span></div>


<div class="viewcode-block" id="evaluate_subcircuits"><a class="viewcode-back" href="../../../../stubs/circuit_knitting_toolbox.circuit_cutting.cutqc.evaluate_subcircuits.html#circuit_knitting_toolbox.circuit_cutting.cutqc.evaluate_subcircuits">[docs]</a><span class="k">def</span> <span class="nf">evaluate_subcircuits</span><span class="p">(</span>
    <span class="n">cuts</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
    <span class="n">service</span><span class="p">:</span> <span class="n">QiskitRuntimeService</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">backend_names</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">options</span><span class="p">:</span> <span class="n">Options</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Options</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluate the subcircuits.</span>

<span class="sd">    Args:</span>
<span class="sd">        cuts: The results of cutting</span>
<span class="sd">        service: A service for connecting to Qiskit Runtime Service</span>
<span class="sd">        options: Options to use on each backend</span>
<span class="sd">        backend_names: The name(s) of the backend(s) to be used</span>

<span class="sd">    Returns:</span>
<span class="sd">        The dictionary containing the results from running each of the subcircuits</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Put backend_names and options in lists to ensure it is unambiguous how to sync them</span>
    <span class="n">backends_list</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">options_list</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Options</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">backend_names</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">backend_names</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="n">Options</span><span class="p">):</span>
            <span class="n">options_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">options</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">options</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">options_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">options</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">backend_names</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">backends_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">backend_names</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">backends_list</span> <span class="o">=</span> <span class="n">backend_names</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="n">Options</span><span class="p">):</span>
            <span class="n">options_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">options</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">backends_list</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">options</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">options_list</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">backends_list</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">options_list</span> <span class="o">=</span> <span class="n">options</span>

    <span class="k">if</span> <span class="n">backend_names</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">backends_list</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">options_list</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The list of backend names is length (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">backends_list</span><span class="p">)</span><span class="si">}</span><span class="s2">), &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;but the list of options is length (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">options_list</span><span class="p">)</span><span class="si">}</span><span class="s2">). &quot;</span>
                <span class="s2">&quot;It is ambiguous how these options should be applied.&quot;</span>
            <span class="p">)</span>

    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">subcircuit_instances</span> <span class="o">=</span> <span class="n">_generate_metadata</span><span class="p">(</span><span class="n">cuts</span><span class="p">)</span>

    <span class="n">subcircuit_instance_probabilities</span> <span class="o">=</span> <span class="n">_run_subcircuits</span><span class="p">(</span>
        <span class="n">cuts</span><span class="p">,</span>
        <span class="n">subcircuit_instances</span><span class="p">,</span>
        <span class="n">service</span><span class="o">=</span><span class="n">service</span><span class="p">,</span>
        <span class="n">backend_names</span><span class="o">=</span><span class="n">backends_list</span><span class="p">,</span>
        <span class="n">options</span><span class="o">=</span><span class="n">options_list</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">subcircuit_instance_probabilities</span></div>


<div class="viewcode-block" id="reconstruct_full_distribution"><a class="viewcode-back" href="../../../../stubs/circuit_knitting_toolbox.circuit_cutting.cutqc.reconstruct_full_distribution.html#circuit_knitting_toolbox.circuit_cutting.cutqc.reconstruct_full_distribution">[docs]</a><span class="k">def</span> <span class="nf">reconstruct_full_distribution</span><span class="p">(</span>
    <span class="n">circuit</span><span class="p">:</span> <span class="n">QuantumCircuit</span><span class="p">,</span>
    <span class="n">subcircuit_instance_probabilities</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]],</span>
    <span class="n">cuts</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
    <span class="n">num_threads</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reconstruct the full probabilities from the subcircuit evaluations.</span>

<span class="sd">    Args:</span>
<span class="sd">        circuit: The original full circuit</span>
<span class="sd">        subcircuit_instance_probabilities: The probability vectors from each</span>
<span class="sd">            of the subcircuit instances, as output by the _run_subcircuits function</span>
<span class="sd">        num_threads: The number of threads to use to parallelize the recomposing</span>

<span class="sd">    Returns:</span>
<span class="sd">        The reconstructed probability vector</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">summation_terms</span><span class="p">,</span> <span class="n">subcircuit_entries</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_generate_metadata</span><span class="p">(</span><span class="n">cuts</span><span class="p">)</span>

    <span class="n">subcircuit_entry_probabilities</span> <span class="o">=</span> <span class="n">_attribute_shots</span><span class="p">(</span>
        <span class="n">subcircuit_entries</span><span class="p">,</span> <span class="n">subcircuit_instance_probabilities</span>
    <span class="p">)</span>

    <span class="n">unordered_probability</span><span class="p">,</span> <span class="n">smart_order</span><span class="p">,</span> <span class="n">overhead</span> <span class="o">=</span> <span class="n">build</span><span class="p">(</span>
        <span class="n">summation_terms</span><span class="o">=</span><span class="n">summation_terms</span><span class="p">,</span>
        <span class="n">subcircuit_entry_probs</span><span class="o">=</span><span class="n">subcircuit_entry_probabilities</span><span class="p">,</span>
        <span class="n">num_cuts</span><span class="o">=</span><span class="n">cuts</span><span class="p">[</span><span class="s2">&quot;num_cuts&quot;</span><span class="p">],</span>
        <span class="n">num_threads</span><span class="o">=</span><span class="n">num_threads</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">reconstructed_probability</span> <span class="o">=</span> <span class="n">generate_reconstructed_output</span><span class="p">(</span>
        <span class="n">circuit</span><span class="p">,</span>
        <span class="n">cuts</span><span class="p">[</span><span class="s2">&quot;subcircuits&quot;</span><span class="p">],</span>
        <span class="n">unordered_probability</span><span class="p">,</span>
        <span class="n">smart_order</span><span class="p">,</span>
        <span class="n">cuts</span><span class="p">[</span><span class="s2">&quot;complete_path_map&quot;</span><span class="p">],</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">reconstructed_probability</span></div>


<span class="k">def</span> <span class="nf">_generate_metadata</span><span class="p">(</span>
    <span class="n">cuts</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span>
    <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
    <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]]],</span>
    <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="o">...</span><span class="p">]],</span> <span class="nb">int</span><span class="p">]],</span>
<span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate metadata used to execute subcircuits and reconstruct probabilities of original circuit.</span>

<span class="sd">    Args:</span>
<span class="sd">        cuts: Results from the cutting step</span>

<span class="sd">    Returns:</span>
<span class="sd">        Information about the 4^(num cuts) summation terms used to reconstruct original</span>
<span class="sd">        probabilities, a dictionary with information on each of the subcircuits, and a dictionary</span>
<span class="sd">        containing indexes for each of the subcircuits</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="p">(</span>
        <span class="n">summation_terms</span><span class="p">,</span>
        <span class="n">subcircuit_entries</span><span class="p">,</span>
        <span class="n">subcircuit_instances</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">=</span> <span class="n">generate_summation_terms</span><span class="p">(</span>
        <span class="n">subcircuits</span><span class="o">=</span><span class="n">cuts</span><span class="p">[</span><span class="s2">&quot;subcircuits&quot;</span><span class="p">],</span>
        <span class="n">complete_path_map</span><span class="o">=</span><span class="n">cuts</span><span class="p">[</span><span class="s2">&quot;complete_path_map&quot;</span><span class="p">],</span>
        <span class="n">num_cuts</span><span class="o">=</span><span class="n">cuts</span><span class="p">[</span><span class="s2">&quot;num_cuts&quot;</span><span class="p">],</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">summation_terms</span><span class="p">,</span> <span class="n">subcircuit_entries</span><span class="p">,</span> <span class="n">subcircuit_instances</span>


<span class="k">def</span> <span class="nf">_run_subcircuits</span><span class="p">(</span>
    <span class="n">cuts</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
    <span class="n">subcircuit_instances</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="o">...</span><span class="p">]],</span> <span class="nb">int</span><span class="p">]],</span>
    <span class="n">service</span><span class="p">:</span> <span class="n">QiskitRuntimeService</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">backend_names</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">options</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Options</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Execute all the subcircuit instances.</span>

<span class="sd">    task[&#39;subcircuit_instance_probs&#39;][subcircuit_idx][subcircuit_instance_idx] = measured prob</span>

<span class="sd">    Args:</span>
<span class="sd">        cuts: Results from the cutting step</span>
<span class="sd">        subcircuit_instances: The dictionary containing the index information for each</span>
<span class="sd">            of the subcircuit instances</span>
<span class="sd">        service: The arguments for the runtime service</span>
<span class="sd">        backend_names: The backend(s) used to run the subcircuits</span>
<span class="sd">        options: Options for the runtime execution of subcircuits</span>

<span class="sd">    Returns:</span>
<span class="sd">        The resulting probabilities from each of the subcircuit instances</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">subcircuit_instance_probs</span> <span class="o">=</span> <span class="n">run_subcircuit_instances</span><span class="p">(</span>
        <span class="n">subcircuits</span><span class="o">=</span><span class="n">cuts</span><span class="p">[</span><span class="s2">&quot;subcircuits&quot;</span><span class="p">],</span>
        <span class="n">subcircuit_instances</span><span class="o">=</span><span class="n">subcircuit_instances</span><span class="p">,</span>
        <span class="n">service</span><span class="o">=</span><span class="n">service</span><span class="p">,</span>
        <span class="n">backend_names</span><span class="o">=</span><span class="n">backend_names</span><span class="p">,</span>
        <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">subcircuit_instance_probs</span>


<span class="k">def</span> <span class="nf">_attribute_shots</span><span class="p">(</span>
    <span class="n">subcircuit_entries</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span>
        <span class="nb">int</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]]</span>
    <span class="p">],</span>
    <span class="n">subcircuit_instance_probs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Attribute the shots into respective subcircuit entries.</span>

<span class="sd">    task[&#39;subcircuit_entry_probs&#39;][subcircuit_idx][subcircuit_entry_idx] = prob</span>

<span class="sd">    Args:</span>
<span class="sd">        subcircuit_entries: Dictionary containing information about each of the</span>
<span class="sd">            subcircuit instances</span>
<span class="sd">        subcircuit_instance_probs: The probability vectors from each of the subcircuit</span>
<span class="sd">            instances, as output by the _run_subcircuits function</span>

<span class="sd">    Returns:</span>
<span class="sd">        A dictionary containing the probability results to each of the appropriate subcircuits</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: A kronecker term is not size two</span>
<span class="sd">        ValueError: There are no subcircuit probs provided</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">subcircuit_entry_probs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">subcircuit_idx</span> <span class="ow">in</span> <span class="n">subcircuit_entries</span><span class="p">:</span>
        <span class="n">subcircuit_entry_probs</span><span class="p">[</span><span class="n">subcircuit_idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">subcircuit_entries</span><span class="p">[</span><span class="n">subcircuit_idx</span><span class="p">]:</span>
            <span class="n">subcircuit_entry_idx</span><span class="p">,</span> <span class="n">kronecker_term</span> <span class="o">=</span> <span class="n">subcircuit_entries</span><span class="p">[</span><span class="n">subcircuit_idx</span><span class="p">][</span>
                <span class="n">label</span>
            <span class="p">]</span>
            <span class="n">subcircuit_entry_prob</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">coefficient</span><span class="p">,</span> <span class="n">subcircuit_instance_idx</span> <span class="ow">in</span> <span class="n">kronecker_term</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">subcircuit_entry_prob</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">subcircuit_entry_prob</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">coefficient</span>
                        <span class="o">*</span> <span class="n">subcircuit_instance_probs</span><span class="p">[</span><span class="n">subcircuit_idx</span><span class="p">][</span>
                            <span class="n">subcircuit_instance_idx</span>
                        <span class="p">]</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">subcircuit_entry_prob</span> <span class="o">+=</span> <span class="p">(</span>
                        <span class="n">coefficient</span>
                        <span class="o">*</span> <span class="n">subcircuit_instance_probs</span><span class="p">[</span><span class="n">subcircuit_idx</span><span class="p">][</span>
                            <span class="n">subcircuit_instance_idx</span>
                        <span class="p">]</span>
                    <span class="p">)</span>

            <span class="k">if</span> <span class="n">subcircuit_entry_prob</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Something unexpected happened during shot attribution.&quot;</span>
                <span class="p">)</span>
            <span class="n">subcircuit_entry_probs</span><span class="p">[</span><span class="n">subcircuit_idx</span><span class="p">][</span>
                <span class="n">subcircuit_entry_idx</span>
            <span class="p">]</span> <span class="o">=</span> <span class="n">subcircuit_entry_prob</span>

    <span class="k">return</span> <span class="n">subcircuit_entry_probs</span>


<span class="nd">@no_type_check</span>
<span class="k">def</span> <span class="nf">find_wire_cuts</span><span class="p">(</span>
    <span class="n">circuit</span><span class="p">:</span> <span class="n">QuantumCircuit</span><span class="p">,</span>
    <span class="n">max_subcircuit_width</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">max_cuts</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">num_subcircuits</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">max_subcircuit_cuts</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">max_subcircuit_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find optimal cuts for the wires.</span>

<span class="sd">    Will print if the model cannot find a solution at all, and will print whether</span>
<span class="sd">    the found solution is optimal or not.</span>

<span class="sd">    Args:</span>
<span class="sd">        circuit: Original quantum circuit to be cut into subcircuits</span>
<span class="sd">        max_subcircuit_width: Max number of qubits in each subcircuit</span>
<span class="sd">        max_cuts: Max total number of cuts allowed</span>
<span class="sd">        num_subcircuits: List of number of subcircuits to try</span>
<span class="sd">        max_subcircuit_cuts: Max number of cuts for a subcircuit</span>
<span class="sd">        max_subcircuit_size: The maximum number of two qubit gates in each</span>
<span class="sd">            subcircuit</span>
<span class="sd">        verbose: Whether to print information about the cut finding or not</span>

<span class="sd">    Returns:</span>
<span class="sd">        The solution found for the cuts</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">stripped_circ</span> <span class="o">=</span> <span class="n">_circuit_stripping</span><span class="p">(</span><span class="n">circuit</span><span class="o">=</span><span class="n">circuit</span><span class="p">)</span>
    <span class="n">n_vertices</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">vertex_ids</span><span class="p">,</span> <span class="n">id_vertices</span> <span class="o">=</span> <span class="n">_read_circuit</span><span class="p">(</span><span class="n">circuit</span><span class="o">=</span><span class="n">stripped_circ</span><span class="p">)</span>
    <span class="n">num_qubits</span> <span class="o">=</span> <span class="n">circuit</span><span class="o">.</span><span class="n">num_qubits</span>
    <span class="n">cut_solution</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">min_cost</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>

    <span class="n">best_mip_model</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">num_subcircuit</span> <span class="ow">in</span> <span class="n">num_subcircuits</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">num_subcircuit</span> <span class="o">*</span> <span class="n">max_subcircuit_width</span> <span class="o">-</span> <span class="p">(</span><span class="n">num_subcircuit</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">num_qubits</span>
            <span class="ow">or</span> <span class="n">num_subcircuit</span> <span class="o">&gt;</span> <span class="n">num_qubits</span>
            <span class="ow">or</span> <span class="n">max_cuts</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">num_subcircuit</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> subcircuits : IMPOSSIBLE&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">num_subcircuit</span><span class="p">))</span>
            <span class="k">continue</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">n_vertices</span><span class="o">=</span><span class="n">n_vertices</span><span class="p">,</span>
            <span class="n">edges</span><span class="o">=</span><span class="n">edges</span><span class="p">,</span>
            <span class="n">vertex_ids</span><span class="o">=</span><span class="n">vertex_ids</span><span class="p">,</span>
            <span class="n">id_vertices</span><span class="o">=</span><span class="n">id_vertices</span><span class="p">,</span>
            <span class="n">num_subcircuit</span><span class="o">=</span><span class="n">num_subcircuit</span><span class="p">,</span>
            <span class="n">max_subcircuit_width</span><span class="o">=</span><span class="n">max_subcircuit_width</span><span class="p">,</span>
            <span class="n">max_subcircuit_cuts</span><span class="o">=</span><span class="n">max_subcircuit_cuts</span><span class="p">,</span>
            <span class="n">max_subcircuit_size</span><span class="o">=</span><span class="n">max_subcircuit_size</span><span class="p">,</span>
            <span class="n">num_qubits</span><span class="o">=</span><span class="n">num_qubits</span><span class="p">,</span>
            <span class="n">max_cuts</span><span class="o">=</span><span class="n">max_cuts</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="kn">from</span> <span class="nn">.mip_model</span> <span class="kn">import</span> <span class="n">MIPModel</span>

        <span class="n">mip_model</span> <span class="o">=</span> <span class="n">MIPModel</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">feasible</span> <span class="o">=</span> <span class="n">mip_model</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">min_postprocessing_cost</span><span class="o">=</span><span class="n">min_cost</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">feasible</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> subcircuits : NO SOLUTIONS&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">num_subcircuit</span><span class="p">))</span>
            <span class="k">continue</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">positions</span> <span class="o">=</span> <span class="n">_cuts_parser</span><span class="p">(</span><span class="n">mip_model</span><span class="o">.</span><span class="n">cut_edges</span><span class="p">,</span> <span class="n">circuit</span><span class="p">)</span>
            <span class="n">subcircuits</span><span class="p">,</span> <span class="n">complete_path_map</span> <span class="o">=</span> <span class="n">_subcircuits_parser</span><span class="p">(</span>
                <span class="n">subcircuit_gates</span><span class="o">=</span><span class="n">mip_model</span><span class="o">.</span><span class="n">subcircuits</span><span class="p">,</span> <span class="n">circuit</span><span class="o">=</span><span class="n">circuit</span>
            <span class="p">)</span>
            <span class="n">O_rho_pairs</span> <span class="o">=</span> <span class="n">_get_pairs</span><span class="p">(</span><span class="n">complete_path_map</span><span class="o">=</span><span class="n">complete_path_map</span><span class="p">)</span>
            <span class="n">counter</span> <span class="o">=</span> <span class="n">_get_counter</span><span class="p">(</span><span class="n">subcircuits</span><span class="o">=</span><span class="n">subcircuits</span><span class="p">,</span> <span class="n">O_rho_pairs</span><span class="o">=</span><span class="n">O_rho_pairs</span><span class="p">)</span>

            <span class="n">classical_cost</span> <span class="o">=</span> <span class="n">_cost_estimate</span><span class="p">(</span><span class="n">counter</span><span class="o">=</span><span class="n">counter</span><span class="p">)</span>
            <span class="n">cost</span> <span class="o">=</span> <span class="n">classical_cost</span>

            <span class="k">if</span> <span class="n">cost</span> <span class="o">&lt;</span> <span class="n">min_cost</span><span class="p">:</span>
                <span class="n">min_cost</span> <span class="o">=</span> <span class="n">cost</span>
                <span class="n">best_mip_model</span> <span class="o">=</span> <span class="n">mip_model</span>
                <span class="n">cut_solution</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;max_subcircuit_width&quot;</span><span class="p">:</span> <span class="n">max_subcircuit_width</span><span class="p">,</span>
                    <span class="s2">&quot;subcircuits&quot;</span><span class="p">:</span> <span class="n">subcircuits</span><span class="p">,</span>
                    <span class="s2">&quot;complete_path_map&quot;</span><span class="p">:</span> <span class="n">complete_path_map</span><span class="p">,</span>
                    <span class="s2">&quot;num_cuts&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">),</span>
                    <span class="s2">&quot;counter&quot;</span><span class="p">:</span> <span class="n">counter</span><span class="p">,</span>
                    <span class="s2">&quot;classical_cost&quot;</span><span class="p">:</span> <span class="n">classical_cost</span><span class="p">,</span>
                <span class="p">}</span>
    <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">cut_solution</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="mi">20</span><span class="p">)</span>
        <span class="n">classical_cost</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">cut_solution</span><span class="p">[</span><span class="s2">&quot;classical_cost&quot;</span><span class="p">])</span>
        <span class="c1"># We can remove typing.Dict from this cast statement when py38 is deprecated.</span>
        <span class="c1"># https://bugs.python.org/issue45117</span>
        <span class="n">counter</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span> <span class="n">cut_solution</span><span class="p">[</span><span class="s2">&quot;counter&quot;</span><span class="p">])</span>
        <span class="n">subcircuits</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="n">cut_solution</span><span class="p">[</span><span class="s2">&quot;subcircuits&quot;</span><span class="p">]</span>
        <span class="n">num_cuts</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">cut_solution</span><span class="p">[</span><span class="s2">&quot;num_cuts&quot;</span><span class="p">]</span>
        <span class="n">_print_cutter_result</span><span class="p">(</span>
            <span class="n">num_subcircuit</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">subcircuits</span><span class="p">),</span>
            <span class="n">num_cuts</span><span class="o">=</span><span class="n">num_cuts</span><span class="p">,</span>
            <span class="n">subcircuits</span><span class="o">=</span><span class="n">subcircuits</span><span class="p">,</span>
            <span class="n">counter</span><span class="o">=</span><span class="n">counter</span><span class="p">,</span>
            <span class="n">classical_cost</span><span class="o">=</span><span class="n">classical_cost</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">best_mip_model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Something went wrong during cut finding. The best MIP model object was never instantiated.&quot;</span>
            <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Model objective value = </span><span class="si">%.2e</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">best_mip_model</span><span class="o">.</span><span class="n">objective</span><span class="p">),</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;MIP runtime:&quot;</span><span class="p">,</span> <span class="n">best_mip_model</span><span class="o">.</span><span class="n">runtime</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">best_mip_model</span><span class="o">.</span><span class="n">optimal</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;OPTIMAL, MIP gap =&quot;</span><span class="p">,</span> <span class="n">best_mip_model</span><span class="o">.</span><span class="n">mip_gap</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;NOT OPTIMAL, MIP gap =&quot;</span><span class="p">,</span> <span class="n">best_mip_model</span><span class="o">.</span><span class="n">mip_gap</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="mi">20</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cut_solution</span>


<span class="k">def</span> <span class="nf">cut_circuit_wire</span><span class="p">(</span>
    <span class="n">circuit</span><span class="p">:</span> <span class="n">QuantumCircuit</span><span class="p">,</span> <span class="n">subcircuit_vertices</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform the provided cuts.</span>

<span class="sd">    Used when cut locations are chosen manually.</span>

<span class="sd">    Args:</span>
<span class="sd">        circuit: Original quantum circuit to be cut into subcircuits</span>
<span class="sd">        subcircuit_vertices: The list of vertices to apply the cuts to</span>
<span class="sd">        verbose: Whether to print the details of cutting or not</span>

<span class="sd">    Returns:</span>
<span class="sd">        The solution calculated from the provided cuts</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">stripped_circ</span> <span class="o">=</span> <span class="n">_circuit_stripping</span><span class="p">(</span><span class="n">circuit</span><span class="o">=</span><span class="n">circuit</span><span class="p">)</span>
    <span class="n">n_vertices</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">vertex_ids</span><span class="p">,</span> <span class="n">id_vertices</span> <span class="o">=</span> <span class="n">_read_circuit</span><span class="p">(</span><span class="n">circuit</span><span class="o">=</span><span class="n">stripped_circ</span><span class="p">)</span>

    <span class="n">subcircuit_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">vertices</span> <span class="ow">in</span> <span class="n">subcircuit_vertices</span><span class="p">:</span>
        <span class="n">subcircuit</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="n">vertices</span><span class="p">:</span>
            <span class="n">subcircuit</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">id_vertices</span><span class="p">[</span><span class="n">vertex</span><span class="p">])</span>
        <span class="n">subcircuit_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subcircuit</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">sum</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">subcircuit</span><span class="p">)</span> <span class="k">for</span> <span class="n">subcircuit</span> <span class="ow">in</span> <span class="n">subcircuit_list</span><span class="p">])</span> <span class="o">!=</span> <span class="n">n_vertices</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Not all gates are assigned into subcircuits&quot;</span><span class="p">)</span>

    <span class="n">subcircuit_object</span> <span class="o">=</span> <span class="n">_subcircuits_parser</span><span class="p">(</span>
        <span class="n">subcircuit_gates</span><span class="o">=</span><span class="n">subcircuit_list</span><span class="p">,</span> <span class="n">circuit</span><span class="o">=</span><span class="n">circuit</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">subcircuit_object</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;subcircuit_object should contain exactly two elements.&quot;</span><span class="p">)</span>
    <span class="n">subcircuits</span> <span class="o">=</span> <span class="n">subcircuit_object</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">complete_path_map</span> <span class="o">=</span> <span class="n">subcircuit_object</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">O_rho_pairs</span> <span class="o">=</span> <span class="n">_get_pairs</span><span class="p">(</span><span class="n">complete_path_map</span><span class="o">=</span><span class="n">complete_path_map</span><span class="p">)</span>
    <span class="n">counter</span> <span class="o">=</span> <span class="n">_get_counter</span><span class="p">(</span><span class="n">subcircuits</span><span class="o">=</span><span class="n">subcircuits</span><span class="p">,</span> <span class="n">O_rho_pairs</span><span class="o">=</span><span class="n">O_rho_pairs</span><span class="p">)</span>
    <span class="n">classical_cost</span> <span class="o">=</span> <span class="n">_cost_estimate</span><span class="p">(</span><span class="n">counter</span><span class="o">=</span><span class="n">counter</span><span class="p">)</span>
    <span class="n">max_subcircuit_width</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">subcirc</span><span class="o">.</span><span class="n">width</span><span class="p">()</span> <span class="k">for</span> <span class="n">subcirc</span> <span class="ow">in</span> <span class="n">subcircuits</span><span class="p">])</span>  <span class="c1"># type: ignore</span>

    <span class="n">cut_solution</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;max_subcircuit_width&quot;</span><span class="p">:</span> <span class="n">max_subcircuit_width</span><span class="p">,</span>
        <span class="s2">&quot;subcircuits&quot;</span><span class="p">:</span> <span class="n">subcircuits</span><span class="p">,</span>
        <span class="s2">&quot;complete_path_map&quot;</span><span class="p">:</span> <span class="n">complete_path_map</span><span class="p">,</span>
        <span class="s2">&quot;num_cuts&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">O_rho_pairs</span><span class="p">),</span>
        <span class="s2">&quot;counter&quot;</span><span class="p">:</span> <span class="n">counter</span><span class="p">,</span>
        <span class="s2">&quot;classical_cost&quot;</span><span class="p">:</span> <span class="n">classical_cost</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="mi">20</span><span class="p">)</span>
        <span class="n">_print_cutter_result</span><span class="p">(</span>
            <span class="n">num_subcircuit</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">cut_solution</span><span class="p">[</span><span class="s2">&quot;subcircuits&quot;</span><span class="p">]),</span>
            <span class="n">num_cuts</span><span class="o">=</span><span class="n">cut_solution</span><span class="p">[</span><span class="s2">&quot;num_cuts&quot;</span><span class="p">],</span>
            <span class="n">subcircuits</span><span class="o">=</span><span class="n">cut_solution</span><span class="p">[</span><span class="s2">&quot;subcircuits&quot;</span><span class="p">],</span>
            <span class="n">counter</span><span class="o">=</span><span class="n">cut_solution</span><span class="p">[</span><span class="s2">&quot;counter&quot;</span><span class="p">],</span>
            <span class="n">classical_cost</span><span class="o">=</span><span class="n">cut_solution</span><span class="p">[</span><span class="s2">&quot;classical_cost&quot;</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="mi">20</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cut_solution</span>


<span class="k">def</span> <span class="nf">_print_cutter_result</span><span class="p">(</span>
    <span class="n">num_subcircuit</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">num_cuts</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">subcircuits</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">QuantumCircuit</span><span class="p">],</span>
    <span class="n">counter</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
    <span class="n">classical_cost</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pretty print the results.</span>

<span class="sd">    Args:</span>
<span class="sd">        num_subciruit: The number of subcircuits</span>
<span class="sd">        num_cuts: The number of cuts</span>
<span class="sd">        subcircuits: The list of subcircuits</span>
<span class="sd">        counter: The dictionary containing all meta information regarding</span>
<span class="sd">            each of the subcircuits</span>
<span class="sd">        classical_cost: The estimated processing cost</span>

<span class="sd">    Returns:</span>
<span class="sd">        None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">subcircuit_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_subcircuit</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;subcircuit </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">subcircuit_idx</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;</span><span class="se">\u03C1</span><span class="s2"> qubits = </span><span class="si">%d</span><span class="s2">, O qubits = </span><span class="si">%d</span><span class="s2">, width = </span><span class="si">%d</span><span class="s2">, effective = </span><span class="si">%d</span><span class="s2">, depth = </span><span class="si">%d</span><span class="s2">, size = </span><span class="si">%d</span><span class="s2">&quot;</span>
            <span class="o">%</span> <span class="p">(</span>
                <span class="n">counter</span><span class="p">[</span><span class="n">subcircuit_idx</span><span class="p">][</span><span class="s2">&quot;rho&quot;</span><span class="p">],</span>
                <span class="n">counter</span><span class="p">[</span><span class="n">subcircuit_idx</span><span class="p">][</span><span class="s2">&quot;O&quot;</span><span class="p">],</span>
                <span class="n">counter</span><span class="p">[</span><span class="n">subcircuit_idx</span><span class="p">][</span><span class="s2">&quot;d&quot;</span><span class="p">],</span>
                <span class="n">counter</span><span class="p">[</span><span class="n">subcircuit_idx</span><span class="p">][</span><span class="s2">&quot;effective&quot;</span><span class="p">],</span>
                <span class="n">counter</span><span class="p">[</span><span class="n">subcircuit_idx</span><span class="p">][</span><span class="s2">&quot;depth&quot;</span><span class="p">],</span>
                <span class="n">counter</span><span class="p">[</span><span class="n">subcircuit_idx</span><span class="p">][</span><span class="s2">&quot;size&quot;</span><span class="p">],</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">subcircuits</span><span class="p">[</span><span class="n">subcircuit_idx</span><span class="p">])</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Estimated cost = </span><span class="si">%.3e</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">classical_cost</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_cuts_parser</span><span class="p">(</span>
    <span class="n">cuts</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">circ</span><span class="p">:</span> <span class="n">QuantumCircuit</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">Qubit</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert cuts to wires.</span>

<span class="sd">    Args:</span>
<span class="sd">        cuts: The cuts found by the model (or provided by the user)</span>
<span class="sd">        circ: The quantum circuit the cuts are from</span>

<span class="sd">    Returns:</span>
<span class="sd">        The list containing the wires that were cut and the gates</span>
<span class="sd">        that are affected by these cuts</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dag</span> <span class="o">=</span> <span class="n">circuit_to_dag</span><span class="p">(</span><span class="n">circ</span><span class="p">)</span>
    <span class="n">positions</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">position</span> <span class="ow">in</span> <span class="n">cuts</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">position</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;position variable should be a length 2 sequence: </span><span class="si">{position}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="n">source</span> <span class="o">=</span> <span class="n">position</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">dest</span> <span class="o">=</span> <span class="n">position</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">source_qargs</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;]&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;]&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;]&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">source</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">dest_qargs</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;]&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;]&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;]&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">dest</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">qubit_cut</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">source_qarg</span> <span class="ow">in</span> <span class="n">source_qargs</span><span class="p">:</span>
            <span class="n">source_qubit</span><span class="p">,</span> <span class="n">source_multi_Q_gate_idx</span> <span class="o">=</span> <span class="n">source_qarg</span>
            <span class="k">for</span> <span class="n">dest_qarg</span> <span class="ow">in</span> <span class="n">dest_qargs</span><span class="p">:</span>
                <span class="n">dest_qubit</span><span class="p">,</span> <span class="n">dest_multi_Q_gate_idx</span> <span class="o">=</span> <span class="n">dest_qarg</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">source_qubit</span> <span class="o">==</span> <span class="n">dest_qubit</span>
                    <span class="ow">and</span> <span class="n">dest_multi_Q_gate_idx</span> <span class="o">==</span> <span class="n">source_multi_Q_gate_idx</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="p">):</span>
                    <span class="n">qubit_cut</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">source_qubit</span><span class="p">)</span>
        <span class="c1"># if len(qubit_cut)&gt;1:</span>
        <span class="c1">#     raise Exception(&#39;one cut is cutting on multiple qubits&#39;)</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">source</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;]&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;]&quot;</span> <span class="o">==</span> <span class="n">qubit_cut</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">source_idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;]&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">dest</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;]&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;]&quot;</span> <span class="o">==</span> <span class="n">qubit_cut</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">dest_idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;]&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">multi_Q_gate_idx</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">source_idx</span><span class="p">,</span> <span class="n">dest_idx</span><span class="p">)</span>

        <span class="n">wire</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">qubit</span> <span class="ow">in</span> <span class="n">circ</span><span class="o">.</span><span class="n">qubits</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">circ</span><span class="o">.</span><span class="n">find_bit</span><span class="p">(</span><span class="n">qubit</span><span class="p">)</span><span class="o">.</span><span class="n">registers</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">qubit_cut</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;[&quot;</span><span class="p">)[</span>
                <span class="mi">0</span>
            <span class="p">]</span> <span class="ow">and</span> <span class="n">circ</span><span class="o">.</span><span class="n">find_bit</span><span class="p">(</span><span class="n">qubit</span><span class="p">)</span><span class="o">.</span><span class="n">index</span> <span class="o">==</span> <span class="nb">int</span><span class="p">(</span>
                <span class="n">qubit_cut</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;[&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;]&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="p">):</span>
                <span class="n">wire</span> <span class="o">=</span> <span class="n">qubit</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">all_Q_gate_idx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">gate_idx</span><span class="p">,</span> <span class="n">gate</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
            <span class="nb">list</span><span class="p">(</span><span class="n">dag</span><span class="o">.</span><span class="n">nodes_on_wire</span><span class="p">(</span><span class="n">wire</span><span class="o">=</span><span class="n">wire</span><span class="p">,</span> <span class="n">only_ops</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">gate</span><span class="o">.</span><span class="n">qargs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">tmp</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">tmp</span> <span class="o">==</span> <span class="n">multi_Q_gate_idx</span><span class="p">:</span>
                    <span class="n">all_Q_gate_idx</span> <span class="o">=</span> <span class="n">gate_idx</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">wire</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">all_Q_gate_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Something unexpected happened while parsing cuts.&quot;</span><span class="p">)</span>
        <span class="n">positions</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">wire</span><span class="p">,</span> <span class="n">all_Q_gate_idx</span><span class="p">))</span>
    <span class="n">positions</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">cut</span><span class="p">:</span> <span class="n">cut</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">positions</span>


<span class="k">def</span> <span class="nf">_subcircuits_parser</span><span class="p">(</span>
    <span class="n">subcircuit_gates</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">circuit</span><span class="p">:</span> <span class="n">QuantumCircuit</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">QuantumCircuit</span><span class="p">],</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Qubit</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">Qubit</span><span class="p">]]]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert the subcircuit gates into quantum circuits and path out the DAGs to enable conversion.</span>

<span class="sd">    Args:</span>
<span class="sd">        subcircuit_gates: The gates in the subcircuits</span>
<span class="sd">        circuit: The original circuit</span>

<span class="sd">    Returns:</span>
<span class="sd">        A tuple containing he subcircuits and the paths in the quantum circuit DAGs</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Assign the single qubit gates to the closest two-qubit gates</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">calculate_distance_between_gate</span><span class="p">(</span><span class="n">gate_A</span><span class="p">,</span> <span class="n">gate_B</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">gate_A</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">gate_B</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)):</span>
            <span class="n">tmp_gate</span> <span class="o">=</span> <span class="n">gate_A</span>
            <span class="n">gate_A</span> <span class="o">=</span> <span class="n">gate_B</span>
            <span class="n">gate_B</span> <span class="o">=</span> <span class="n">tmp_gate</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">qarg_A</span> <span class="ow">in</span> <span class="n">gate_A</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">):</span>
            <span class="n">qubit_A</span> <span class="o">=</span> <span class="n">qarg_A</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;]&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;]&quot;</span>
            <span class="n">qgate_A</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">qarg_A</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;]&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">qarg_B</span> <span class="ow">in</span> <span class="n">gate_B</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">):</span>
                <span class="n">qubit_B</span> <span class="o">=</span> <span class="n">qarg_B</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;]&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;]&quot;</span>
                <span class="n">qgate_B</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">qarg_B</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;]&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="c1"># print(&#39;%s gate %d --&gt; %s gate %d&#39;%(qubit_A,qgate_A,qubit_B,qgate_B))</span>
                <span class="k">if</span> <span class="n">qubit_A</span> <span class="o">==</span> <span class="n">qubit_B</span><span class="p">:</span>
                    <span class="n">distance</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">qgate_B</span> <span class="o">-</span> <span class="n">qgate_A</span><span class="p">))</span>
        <span class="c1"># print(&#39;Distance from %s to %s = %f&#39;%(gate_A,gate_B,distance))</span>
        <span class="k">return</span> <span class="n">distance</span>

    <span class="n">dag</span> <span class="o">=</span> <span class="n">circuit_to_dag</span><span class="p">(</span><span class="n">circuit</span><span class="p">)</span>
    <span class="n">qubit_allGate_depths</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">circuit</span><span class="o">.</span><span class="n">qubits</span><span class="p">}</span>
    <span class="n">qubit_2qGate_depths</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">circuit</span><span class="o">.</span><span class="n">qubits</span><span class="p">}</span>
    <span class="n">gate_depth_encodings</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c1"># print(&#39;Before translation :&#39;,subcircuit_gates,flush=True)</span>
    <span class="k">for</span> <span class="n">op_node</span> <span class="ow">in</span> <span class="n">dag</span><span class="o">.</span><span class="n">topological_op_nodes</span><span class="p">():</span>
        <span class="n">gate_depth_encoding</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">for</span> <span class="n">qarg</span> <span class="ow">in</span> <span class="n">op_node</span><span class="o">.</span><span class="n">qargs</span><span class="p">:</span>
            <span class="n">gate_depth_encoding</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">[</span><span class="si">%d</span><span class="s2">]</span><span class="si">%d</span><span class="s2"> &quot;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="n">circuit</span><span class="o">.</span><span class="n">find_bit</span><span class="p">(</span><span class="n">qarg</span><span class="p">)</span><span class="o">.</span><span class="n">registers</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                <span class="n">circuit</span><span class="o">.</span><span class="n">find_bit</span><span class="p">(</span><span class="n">qarg</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
                <span class="n">qubit_allGate_depths</span><span class="p">[</span><span class="n">qarg</span><span class="p">],</span>
            <span class="p">)</span>
        <span class="n">gate_depth_encoding</span> <span class="o">=</span> <span class="n">gate_depth_encoding</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">gate_depth_encodings</span><span class="p">[</span><span class="n">op_node</span><span class="p">]</span> <span class="o">=</span> <span class="n">gate_depth_encoding</span>
        <span class="k">for</span> <span class="n">qarg</span> <span class="ow">in</span> <span class="n">op_node</span><span class="o">.</span><span class="n">qargs</span><span class="p">:</span>
            <span class="n">qubit_allGate_depths</span><span class="p">[</span><span class="n">qarg</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">op_node</span><span class="o">.</span><span class="n">qargs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">MIP_gate_depth_encoding</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="k">for</span> <span class="n">qarg</span> <span class="ow">in</span> <span class="n">op_node</span><span class="o">.</span><span class="n">qargs</span><span class="p">:</span>
                <span class="n">MIP_gate_depth_encoding</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">[</span><span class="si">%d</span><span class="s2">]</span><span class="si">%d</span><span class="s2"> &quot;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="n">circuit</span><span class="o">.</span><span class="n">find_bit</span><span class="p">(</span><span class="n">qarg</span><span class="p">)</span><span class="o">.</span><span class="n">registers</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                    <span class="n">circuit</span><span class="o">.</span><span class="n">find_bit</span><span class="p">(</span><span class="n">qarg</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
                    <span class="n">qubit_2qGate_depths</span><span class="p">[</span><span class="n">qarg</span><span class="p">],</span>
                <span class="p">)</span>
                <span class="n">qubit_2qGate_depths</span><span class="p">[</span><span class="n">qarg</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">MIP_gate_depth_encoding</span> <span class="o">=</span> <span class="n">MIP_gate_depth_encoding</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># print(&#39;gate_depth_encoding = %s, MIP_gate_depth_encoding = %s&#39;%(gate_depth_encoding,MIP_gate_depth_encoding))</span>
            <span class="k">for</span> <span class="n">subcircuit_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">subcircuit_gates</span><span class="p">)):</span>
                <span class="k">for</span> <span class="n">gate_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">subcircuit_gates</span><span class="p">[</span><span class="n">subcircuit_idx</span><span class="p">])):</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="n">subcircuit_gates</span><span class="p">[</span><span class="n">subcircuit_idx</span><span class="p">][</span><span class="n">gate_idx</span><span class="p">]</span>
                        <span class="o">==</span> <span class="n">MIP_gate_depth_encoding</span>
                    <span class="p">):</span>
                        <span class="n">subcircuit_gates</span><span class="p">[</span><span class="n">subcircuit_idx</span><span class="p">][</span><span class="n">gate_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">gate_depth_encoding</span>
                        <span class="k">break</span>
    <span class="c1"># print(&#39;After translation :&#39;,subcircuit_gates,flush=True)</span>
    <span class="n">subcircuit_op_nodes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">DAGOpNode</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">x</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">subcircuit_gates</span><span class="p">))</span>
    <span class="p">}</span>
    <span class="n">subcircuit_sizes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">subcircuit_gates</span><span class="p">))]</span>
    <span class="n">complete_path_map</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Qubit</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">Qubit</span><span class="p">]]]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">circuit_qubit</span> <span class="ow">in</span> <span class="n">dag</span><span class="o">.</span><span class="n">qubits</span><span class="p">:</span>
        <span class="n">complete_path_map</span><span class="p">[</span><span class="n">circuit_qubit</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">qubit_ops</span> <span class="o">=</span> <span class="n">dag</span><span class="o">.</span><span class="n">nodes_on_wire</span><span class="p">(</span><span class="n">wire</span><span class="o">=</span><span class="n">circuit_qubit</span><span class="p">,</span> <span class="n">only_ops</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">qubit_op_idx</span><span class="p">,</span> <span class="n">qubit_op</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">qubit_ops</span><span class="p">):</span>
            <span class="n">gate_depth_encoding</span> <span class="o">=</span> <span class="n">gate_depth_encodings</span><span class="p">[</span><span class="n">qubit_op</span><span class="p">]</span>
            <span class="n">nearest_subcircuit_idx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">min_distance</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">subcircuit_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">subcircuit_gates</span><span class="p">)):</span>
                <span class="n">distance</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">gate</span> <span class="ow">in</span> <span class="n">subcircuit_gates</span><span class="p">[</span><span class="n">subcircuit_idx</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">gate</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="c1"># Do not compare against single qubit gates</span>
                        <span class="k">continue</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">distance</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                            <span class="n">distance</span><span class="p">,</span>
                            <span class="n">calculate_distance_between_gate</span><span class="p">(</span>
                                <span class="n">gate_A</span><span class="o">=</span><span class="n">gate_depth_encoding</span><span class="p">,</span> <span class="n">gate_B</span><span class="o">=</span><span class="n">gate</span>
                            <span class="p">),</span>
                        <span class="p">)</span>
                <span class="c1"># print(&#39;Distance from %s to subcircuit %d = %f&#39;%(gate_depth_encoding,subcircuit_idx,distance))</span>
                <span class="k">if</span> <span class="n">distance</span> <span class="o">&lt;</span> <span class="n">min_distance</span><span class="p">:</span>
                    <span class="n">min_distance</span> <span class="o">=</span> <span class="n">distance</span>
                    <span class="n">nearest_subcircuit_idx</span> <span class="o">=</span> <span class="n">subcircuit_idx</span>
            <span class="k">assert</span> <span class="n">nearest_subcircuit_idx</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">path_element</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;subcircuit_idx&quot;</span><span class="p">:</span> <span class="n">nearest_subcircuit_idx</span><span class="p">,</span>
                <span class="s2">&quot;subcircuit_qubit&quot;</span><span class="p">:</span> <span class="n">subcircuit_sizes</span><span class="p">[</span><span class="n">nearest_subcircuit_idx</span><span class="p">],</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">complete_path_map</span><span class="p">[</span><span class="n">circuit_qubit</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span>
                <span class="ow">or</span> <span class="n">nearest_subcircuit_idx</span>
                <span class="o">!=</span> <span class="n">complete_path_map</span><span class="p">[</span><span class="n">circuit_qubit</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;subcircuit_idx&quot;</span><span class="p">]</span>
            <span class="p">):</span>
                <span class="c1"># print(&#39;{} op #{:d} {:s} encoding = {:s}&#39;.format(circuit_qubit,qubit_op_idx,qubit_op.name,gate_depth_encoding),</span>
                <span class="c1"># &#39;belongs in subcircuit %d&#39;%nearest_subcircuit_idx)</span>
                <span class="n">complete_path_map</span><span class="p">[</span><span class="n">circuit_qubit</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">path_element</span><span class="p">)</span>
                <span class="n">subcircuit_sizes</span><span class="p">[</span><span class="n">nearest_subcircuit_idx</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="n">subcircuit_op_nodes</span><span class="p">[</span><span class="n">nearest_subcircuit_idx</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">qubit_op</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">circuit_qubit</span> <span class="ow">in</span> <span class="n">complete_path_map</span><span class="p">:</span>
        <span class="c1"># print(circuit_qubit,&#39;--&gt;&#39;)</span>
        <span class="k">for</span> <span class="n">path_element</span> <span class="ow">in</span> <span class="n">complete_path_map</span><span class="p">[</span><span class="n">circuit_qubit</span><span class="p">]:</span>
            <span class="n">path_element_qubit</span> <span class="o">=</span> <span class="n">QuantumRegister</span><span class="p">(</span>
                <span class="n">size</span><span class="o">=</span><span class="n">subcircuit_sizes</span><span class="p">[</span><span class="n">path_element</span><span class="p">[</span><span class="s2">&quot;subcircuit_idx&quot;</span><span class="p">]],</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;q&quot;</span>
            <span class="p">)[</span><span class="n">path_element</span><span class="p">[</span><span class="s2">&quot;subcircuit_qubit&quot;</span><span class="p">]]</span>
            <span class="n">path_element</span><span class="p">[</span><span class="s2">&quot;subcircuit_qubit&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">path_element_qubit</span>
            <span class="c1"># print(path_element)</span>
    <span class="n">subcircuits</span> <span class="o">=</span> <span class="n">_generate_subcircuits</span><span class="p">(</span>
        <span class="n">subcircuit_op_nodes</span><span class="o">=</span><span class="n">subcircuit_op_nodes</span><span class="p">,</span>
        <span class="n">complete_path_map</span><span class="o">=</span><span class="n">complete_path_map</span><span class="p">,</span>
        <span class="n">subcircuit_sizes</span><span class="o">=</span><span class="n">subcircuit_sizes</span><span class="p">,</span>
        <span class="n">dag</span><span class="o">=</span><span class="n">dag</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">subcircuits</span><span class="p">,</span> <span class="n">complete_path_map</span>


<span class="k">def</span> <span class="nf">_generate_subcircuits</span><span class="p">(</span>
    <span class="n">subcircuit_op_nodes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">DAGOpNode</span><span class="p">]],</span>
    <span class="n">complete_path_map</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Qubit</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">Qubit</span><span class="p">]]],</span>
    <span class="n">subcircuit_sizes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="n">dag</span><span class="p">:</span> <span class="n">DAGCircuit</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">QuantumCircuit</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate the subcircuits from given nodes and paths.</span>

<span class="sd">    Called in the subcircuit_parser function to convert the found paths and nodes</span>
<span class="sd">    into actual quantum circuit objects.</span>

<span class="sd">    Args:</span>
<span class="sd">        subcircuit_op_nodes: The nodes of each of the subcircuits</span>
<span class="sd">        complete_path_map: The complete path through the subcircuits</span>
<span class="sd">        subcircuit_sizes: The number of qubits in each of the subcircuits</span>
<span class="sd">        dag: The dag representation of the input quantum circuit</span>

<span class="sd">    Returns:</span>
<span class="sd">        The subcircuits</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">qubit_pointers</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">complete_path_map</span><span class="p">}</span>
    <span class="n">subcircuits</span> <span class="o">=</span> <span class="p">[</span><span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;q&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">subcircuit_sizes</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">op_node</span> <span class="ow">in</span> <span class="n">dag</span><span class="o">.</span><span class="n">topological_op_nodes</span><span class="p">():</span>
        <span class="n">subcircuit_idx_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="nb">filter</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">op_node</span> <span class="ow">in</span> <span class="n">subcircuit_op_nodes</span><span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="n">subcircuit_op_nodes</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">subcircuit_idx_list</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;A node cannot belong to more than one subcircuit.&quot;</span><span class="p">)</span>
        <span class="n">subcircuit_idx</span> <span class="o">=</span> <span class="n">subcircuit_idx_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># print(&#39;{} belongs in subcircuit {:d}&#39;.format(op_node.qargs,subcircuit_idx))</span>
        <span class="n">subcircuit_qargs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">op_node_qarg</span> <span class="ow">in</span> <span class="n">op_node</span><span class="o">.</span><span class="n">qargs</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">complete_path_map</span><span class="p">[</span><span class="n">op_node_qarg</span><span class="p">][</span><span class="n">qubit_pointers</span><span class="p">[</span><span class="n">op_node_qarg</span><span class="p">]][</span>
                    <span class="s2">&quot;subcircuit_idx&quot;</span>
                <span class="p">]</span>
                <span class="o">!=</span> <span class="n">subcircuit_idx</span>
            <span class="p">):</span>
                <span class="n">qubit_pointers</span><span class="p">[</span><span class="n">op_node_qarg</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">path_element</span> <span class="o">=</span> <span class="n">complete_path_map</span><span class="p">[</span><span class="n">op_node_qarg</span><span class="p">][</span><span class="n">qubit_pointers</span><span class="p">[</span><span class="n">op_node_qarg</span><span class="p">]]</span>
            <span class="k">assert</span> <span class="n">path_element</span><span class="p">[</span><span class="s2">&quot;subcircuit_idx&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">subcircuit_idx</span>
            <span class="n">subcircuit_qargs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">path_element</span><span class="p">[</span><span class="s2">&quot;subcircuit_qubit&quot;</span><span class="p">])</span>
        <span class="c1"># print(&#39;--&gt;&#39;,subcircuit_qargs)</span>

        <span class="c1"># mypy doesn&#39;t recognize QuantumCircuit as being an Iterable, so we ignore</span>
        <span class="n">subcircuits</span><span class="p">[</span><span class="n">subcircuit_idx</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>  <span class="c1"># type: ignore</span>
            <span class="n">instruction</span><span class="o">=</span><span class="n">op_node</span><span class="o">.</span><span class="n">op</span><span class="p">,</span> <span class="n">qargs</span><span class="o">=</span><span class="n">subcircuit_qargs</span><span class="p">,</span> <span class="n">cargs</span><span class="o">=</span><span class="kc">None</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">subcircuits</span>


<span class="k">def</span> <span class="nf">_get_counter</span><span class="p">(</span>
    <span class="n">subcircuits</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">QuantumCircuit</span><span class="p">],</span>
    <span class="n">O_rho_pairs</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">Qubit</span><span class="p">],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">Qubit</span><span class="p">]]],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create information regarding each of the subcircuit parameters (qubits, width, etc.).</span>

<span class="sd">    Args:</span>
<span class="sd">        subcircuits: The list of subcircuits</span>
<span class="sd">        O_rho_pairs: The pairs for each qubit path as generated in the _get_pairs function</span>

<span class="sd">    Returns:</span>
<span class="sd">        The resulting dictionary with all parameter information</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">counter</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">subcircuit_idx</span><span class="p">,</span> <span class="n">subcircuit</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">subcircuits</span><span class="p">):</span>
        <span class="n">counter</span><span class="p">[</span><span class="n">subcircuit_idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;effective&quot;</span><span class="p">:</span> <span class="n">subcircuit</span><span class="o">.</span><span class="n">num_qubits</span><span class="p">,</span>
            <span class="s2">&quot;rho&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s2">&quot;O&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s2">&quot;d&quot;</span><span class="p">:</span> <span class="n">subcircuit</span><span class="o">.</span><span class="n">num_qubits</span><span class="p">,</span>
            <span class="s2">&quot;depth&quot;</span><span class="p">:</span> <span class="n">subcircuit</span><span class="o">.</span><span class="n">depth</span><span class="p">(),</span>
            <span class="s2">&quot;size&quot;</span><span class="p">:</span> <span class="n">subcircuit</span><span class="o">.</span><span class="n">size</span><span class="p">(),</span>
        <span class="p">}</span>
    <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">O_rho_pairs</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;O_rho_pairs must be length 2: </span><span class="si">{</span><span class="n">pair</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">O_qubit</span> <span class="o">=</span> <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">rho_qubit</span> <span class="o">=</span> <span class="n">pair</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">counter</span><span class="p">[</span><span class="n">O_qubit</span><span class="p">[</span><span class="s2">&quot;subcircuit_idx&quot;</span><span class="p">]][</span><span class="s2">&quot;effective&quot;</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">counter</span><span class="p">[</span><span class="n">O_qubit</span><span class="p">[</span><span class="s2">&quot;subcircuit_idx&quot;</span><span class="p">]][</span><span class="s2">&quot;O&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">counter</span><span class="p">[</span><span class="n">rho_qubit</span><span class="p">[</span><span class="s2">&quot;subcircuit_idx&quot;</span><span class="p">]][</span><span class="s2">&quot;rho&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">counter</span>


<span class="k">def</span> <span class="nf">_cost_estimate</span><span class="p">(</span><span class="n">counter</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Estimate the cost of processing the subcircuits.</span>

<span class="sd">    Args:</span>
<span class="sd">        counter: Dictionary containing information for each of the subcircuits</span>

<span class="sd">    Returns:</span>
<span class="sd">        The estimated cost for classical processing</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">num_cuts</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">counter</span><span class="p">[</span><span class="n">subcircuit_idx</span><span class="p">][</span><span class="s2">&quot;rho&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">subcircuit_idx</span> <span class="ow">in</span> <span class="n">counter</span><span class="p">])</span>
    <span class="n">subcircuit_indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">counter</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">num_effective_qubits_list</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">counter</span><span class="p">[</span><span class="n">subcircuit_idx</span><span class="p">][</span><span class="s2">&quot;effective&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">subcircuit_idx</span> <span class="ow">in</span> <span class="n">subcircuit_indices</span>
    <span class="p">]</span>
    <span class="n">num_effective_qubits</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span>
        <span class="o">*</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">num_effective_qubits_list</span><span class="p">,</span> <span class="n">subcircuit_indices</span><span class="p">))</span>
    <span class="p">)</span>
    <span class="n">classical_cost</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">accumulated_kron_len</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="n">num_effective_qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">effective</span> <span class="ow">in</span> <span class="n">num_effective_qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="n">accumulated_kron_len</span> <span class="o">*=</span> <span class="mi">2</span><span class="o">**</span><span class="n">effective</span>
        <span class="n">classical_cost</span> <span class="o">+=</span> <span class="n">accumulated_kron_len</span>
    <span class="n">classical_cost</span> <span class="o">*=</span> <span class="mi">4</span><span class="o">**</span><span class="n">num_cuts</span>
    <span class="k">return</span> <span class="n">classical_cost</span>


<span class="k">def</span> <span class="nf">_get_pairs</span><span class="p">(</span>
    <span class="n">complete_path_map</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Qubit</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">Qubit</span><span class="p">]]]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">Qubit</span><span class="p">],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">Qubit</span><span class="p">]]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get all pairs through each path.</span>

<span class="sd">    Iterates through the path for each of the qubits and keeps track of the</span>
<span class="sd">    each pair of neigbors.</span>

<span class="sd">    Args:</span>
<span class="sd">        complete_path_map: The dictionary containing all path information</span>

<span class="sd">    Returns:</span>
<span class="sd">        All pairs for each of the qubit paths</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">O_rho_pairs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">input_qubit</span> <span class="ow">in</span> <span class="n">complete_path_map</span><span class="p">:</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">complete_path_map</span><span class="p">[</span><span class="n">input_qubit</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">path_ctr</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">path</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">O_qubit_tuple</span> <span class="o">=</span> <span class="n">item</span>
                <span class="n">rho_qubit_tuple</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="n">path_ctr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">O_rho_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">O_qubit_tuple</span><span class="p">,</span> <span class="n">rho_qubit_tuple</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">O_rho_pairs</span>


<span class="k">def</span> <span class="nf">_circuit_stripping</span><span class="p">(</span><span class="n">circuit</span><span class="p">:</span> <span class="n">QuantumCircuit</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">QuantumCircuit</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Remove all single qubit and barrier type gates.</span>

<span class="sd">    Args:</span>
<span class="sd">        circuit: The circuit to strip</span>

<span class="sd">    Returns:</span>
<span class="sd">        The stripped circuit</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Remove all single qubit gates and barriers in the circuit</span>
    <span class="n">dag</span> <span class="o">=</span> <span class="n">circuit_to_dag</span><span class="p">(</span><span class="n">circuit</span><span class="p">)</span>
    <span class="n">stripped_dag</span> <span class="o">=</span> <span class="n">DAGCircuit</span><span class="p">()</span>
    <span class="p">[</span><span class="n">stripped_dag</span><span class="o">.</span><span class="n">add_qreg</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">circuit</span><span class="o">.</span><span class="n">qregs</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="n">dag</span><span class="o">.</span><span class="n">topological_op_nodes</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertex</span><span class="o">.</span><span class="n">qargs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">vertex</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="s2">&quot;barrier&quot;</span><span class="p">:</span>
            <span class="n">stripped_dag</span><span class="o">.</span><span class="n">apply_operation_back</span><span class="p">(</span><span class="n">op</span><span class="o">=</span><span class="n">vertex</span><span class="o">.</span><span class="n">op</span><span class="p">,</span> <span class="n">qargs</span><span class="o">=</span><span class="n">vertex</span><span class="o">.</span><span class="n">qargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dag_to_circuit</span><span class="p">(</span><span class="n">stripped_dag</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_read_circuit</span><span class="p">(</span>
    <span class="n">circuit</span><span class="p">:</span> <span class="n">QuantumCircuit</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Read the input circuit to a graph based representation for the MIP model.</span>

<span class="sd">    Args:</span>
<span class="sd">        circuit: A stripped circuit to be converted into a DAG like representation</span>

<span class="sd">    Returns:</span>
<span class="sd">        A tuple containing the number of vertices, edge list, vertex to vertex id mapping,</span>
<span class="sd">        and vertex id to vertex mapping.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dag</span> <span class="o">=</span> <span class="n">circuit_to_dag</span><span class="p">(</span><span class="n">circuit</span><span class="p">)</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">node_name_ids</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">id_node_names</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">vertex_ids</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">curr_node_id</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">qubit_gate_counter</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">qubit</span> <span class="ow">in</span> <span class="n">dag</span><span class="o">.</span><span class="n">qubits</span><span class="p">:</span>
        <span class="n">qubit_gate_counter</span><span class="p">[</span><span class="n">qubit</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="n">dag</span><span class="o">.</span><span class="n">topological_op_nodes</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertex</span><span class="o">.</span><span class="n">qargs</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;vertex does not have 2 qargs!&quot;</span><span class="p">)</span>
        <span class="n">arg0</span><span class="p">,</span> <span class="n">arg1</span> <span class="o">=</span> <span class="n">vertex</span><span class="o">.</span><span class="n">qargs</span>
        <span class="n">vertex_name</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">[</span><span class="si">%d</span><span class="s2">]</span><span class="si">%d</span><span class="s2"> </span><span class="si">%s</span><span class="s2">[</span><span class="si">%d</span><span class="s2">]</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">find_bit</span><span class="p">(</span><span class="n">arg0</span><span class="p">)</span><span class="o">.</span><span class="n">registers</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">find_bit</span><span class="p">(</span><span class="n">arg0</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
            <span class="n">qubit_gate_counter</span><span class="p">[</span><span class="n">arg0</span><span class="p">],</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">find_bit</span><span class="p">(</span><span class="n">arg1</span><span class="p">)</span><span class="o">.</span><span class="n">registers</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">find_bit</span><span class="p">(</span><span class="n">arg1</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
            <span class="n">qubit_gate_counter</span><span class="p">[</span><span class="n">arg1</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="n">qubit_gate_counter</span><span class="p">[</span><span class="n">arg0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">qubit_gate_counter</span><span class="p">[</span><span class="n">arg1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># print(vertex.op.label,vertex_name,curr_node_id)</span>
        <span class="k">if</span> <span class="n">vertex_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">node_name_ids</span> <span class="ow">and</span> <span class="nb">id</span><span class="p">(</span><span class="n">vertex</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">vertex_ids</span><span class="p">:</span>
            <span class="n">node_name_ids</span><span class="p">[</span><span class="n">vertex_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_node_id</span>
            <span class="n">id_node_names</span><span class="p">[</span><span class="n">curr_node_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">vertex_name</span>
            <span class="n">vertex_ids</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">vertex</span><span class="p">)]</span> <span class="o">=</span> <span class="n">curr_node_id</span>
            <span class="n">curr_node_id</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">dag</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">DAGOpNode</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">DAGOpNode</span><span class="p">):</span>
            <span class="n">u_id</span> <span class="o">=</span> <span class="n">vertex_ids</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">u</span><span class="p">)]</span>
            <span class="n">v_id</span> <span class="o">=</span> <span class="n">vertex_ids</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">v</span><span class="p">)]</span>
            <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">u_id</span><span class="p">,</span> <span class="n">v_id</span><span class="p">))</span>

    <span class="n">n_vertices</span> <span class="o">=</span> <span class="n">dag</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">n_vertices</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">node_name_ids</span><span class="p">,</span> <span class="n">id_node_names</span>
</pre></div>
        </article>
      </div>
      <footer>
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2023
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer no-toc">
      
      
      
    </aside>
  </div>
</div><script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/sphinx_highlight.js"></script>
    <script src="../../../../_static/thebelab-helper.js"></script>
    <script src="../../../../_static/clipboard.min.js"></script>
    <script src="../../../../_static/copybutton.js"></script>
    <script src="../../../../_static/scripts/qiskit-sphinx-theme.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    </body>
</html>